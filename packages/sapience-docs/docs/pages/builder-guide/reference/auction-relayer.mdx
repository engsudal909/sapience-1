---
title: "Auction Relayer Reference"
description: "Message channels, payload shapes, validation, signatures, and limits."
---

# Auction Relayer Reference

Canonical WebSocket channels, payload shapes, validations, acknowledgments, broadcasts, and signature semantics for the Auction Relayer.

> For a quick start and a minimal working bot, see Guides → Build a Auction Bot.

## Endpoint

- Production: `wss://api.sapience.xyz/auction` (confirm base URL)
- Local dev (monorepo): `ws://localhost:3001/auction`

## Message flow

- `auction.start` (by taker) → relayer replies `auction.ack` and broadcasts `auction.started` to all clients
- `auction.subscribe` → client subscribes to a specific `auctionId` to receive `auction.bids`
- `bid.submit` (by maker) → relayer replies `bid.ack` and broadcasts `auction.bids` to subscribers of that `auctionId`

Auctions are short-lived (~60s TTL). The socket that sends `auction.start` is auto-subscribed to that auction channel.

## Schemas

### auction.start
Client → Relayer
```ts
{
  type: 'auction.start',
  payload: {
    taker: string,                 // 0x... EOA (starts the auction)
    wager: string,                 // wei string (> 0)
    predictions: Array<{
      resolverContract: string,    // 0x... resolver contract
      predictedOutcomes: string    // bytes (non-empty)
    }>,
    takerNonce: number,            // nonce for the taker
    chainId: number,               // chain where signatures will be verified
    marketContract: string         // 0x... market entrypoint
  }
}
```

Acknowledgment
```ts
{ type: 'auction.ack', payload: { auctionId: string } }
```

Broadcast to all clients
```ts
{ type: 'auction.started', payload: {
    auctionId: string,
    taker: string,
    wager: string,
    predictions: Array<{
      resolverContract: string,
      predictedOutcomes: string
    }>,
    takerNonce: number,
    chainId: number,
    marketContract: string
}}
```

### auction.subscribe
Client → Relayer
```ts
{
  type: 'auction.subscribe',
  payload: { auctionId: string }
}
```

If accepted, the relayer will immediately stream current bids, if any:
```ts
{ type: 'auction.bids', payload: { auctionId: string, bids: ValidatedBid[] } }
```

### bid.submit
Maker → Relayer
```ts
{
  type: 'bid.submit',
  payload: {
    auctionId: string,
    maker: string,          // 0x... EOA (bidding party)
    makerWager: string,     // wei string (>0)
    makerDeadline: number,  // unix seconds (future)
    makerSignature: string, // 0x... hex (typed signature)
    makerNonce: number      // maker nonce (independent)
  }
}
```

Acknowledgment to submitting socket
```ts
{ type: 'bid.ack', payload: { error?: string } }
```

Broadcast to auction subscribers of this `auctionId`
```ts
{ type: 'auction.bids', payload: {
    auctionId: string,
    bids: Array<{
      auctionId: string,
      makerSignature: string,
      maker: string,
      makerWager: string,
      makerDeadline: number,
      makerNonce: number
    }>
}}
```

### Notes
- `auctionId` is generated by the relayer as a deterministic hash of auction fields (including a hash of `predictions`), with TTL between 5s and 5 minutes (default 60s).
- `makerNonce` must be consistent across the auction and all bids for that auction.
- The relayer buffers all valid bids; selection is client-side (e.g., highest `makerWager` among non-expired).

## Validation

Server-side checks (summarized from `packages/api/src/auction/sim.ts`, `helpers.ts`, `registry.ts`, and `ws.ts`).

### Auction payload
- `wager` must parse to BigInt and be > 0
- `predictions` must be an array with ≥1 item
- each prediction must include `resolverContract` and non-empty `predictedOutcomes`
- a single unique resolver across all predictions is required today; otherwise `CROSS_VERIFIER_UNSUPPORTED`
- `taker` must be a valid `0x` address (40 hex)
- `takerNonce` must be a number
- `chainId` must be a number
- `marketContract` must be a valid `0x` address

### Bid payload
- `auctionId` must be a non-empty string of an active auction
- `maker` must be a valid `0x` address (40 hex)
- `makerWager` must parse to BigInt and be > 0
- `makerDeadline` must be a finite number strictly greater than `now` (unix seconds)
- `makerSignature` must be a hex string starting with `0x` and a sensible length
- `makerNonce` must be a number

If any check fails, `bid.ack` includes an `error` string. Common reasons:
- `invalid_payload`
- `invalid_auction_id`
- `invalid_maker`
- `invalid_maker_wager`
- `invalid_wager_values`
- `quote_expired`
- `invalid_maker_bid_signature_format`
- `auction_not_found_or_expired`

## Signature semantics (strict mode)

Basic format checks are always applied. The relayer performs optional EIP-712 verification using fields from the auction payload (see `verifyMakerBidStrict`). This check is best-effort: failures are logged but do not reject the bid if basic validation passed.

Typed inner message hash (Solidity-compatible):
```ts
// encodeAbiParameters([
//   { type: 'bytes32' },      // predictionsHash (order-invariant hash of predictions[])
//   { type: 'uint256' },      // makerWager (bidder's contribution)
//   { type: 'uint256' },      // makerDeadline
// ], [ ... ]) → keccak256(inner) → messageHash
```

EIP-712 domain:
```ts
{ name: 'SignatureProcessor', version: '1', chainId: auction.chainId, verifyingContract: auction.marketContract }
```

Types and primary type:
```ts
Approve: [
  { name: 'messageHash', type: 'bytes32' },
  { name: 'owner', type: 'address' },
]
// message: { messageHash, owner: maker }
```

The maker signs this `Approve` typed data; the server verifies with `verifyTypedData` from `viem`.

## Rate limits and sizes

- 100 messages per 10s window; on exceed → close with code `1008`, reason `rate_limited`
- Message size > 64,000 bytes → close with code `1009`, reason `message_too_large`

## Expiration and subscriptions

- Auctions expire after a TTL between 5 seconds and 5 minutes (default 60 seconds); expired auctions are removed.
- The socket that sends `auction.start` is auto-subscribed to that `auctionId`.
- Other clients may call `auction.subscribe` to receive `auction.bids` for that `auctionId`.
- `auction.bids` broadcasts only to subscribers of that `auctionId`.

## On-chain flow context

Relayer focuses on off-chain matching and signature validation. On-chain minting and settlement are handled by `PredictionMarket.sol` (and related contracts). Key checks performed on-chain at `mint` include:

- Maker must be the caller (`MakerIsNotCaller`)
- `takerDeadline` must be in the future (`TakerDeadlineExpired`)
- Non-zero collaterals and above minimum (`MakerCollateralMustBeGreaterThanZero`, `TakerCollateralMustBeGreaterThanZero`, `CollateralBelowMinimum`)
- Non-empty `encodedPredictedOutcomes` (`InvalidEncodedPredictedOutcomes`)
- Taker signature validity (EOA or ERC-1271) over the same preimage described above (`InvalidTakerSignature`)
- Market validation via resolver (`InvalidMarketsAccordingToResolver`)

Both parties must set ERC-20 approvals to allow the contract to pull their collateral.

## Example messages

### auction.start
```ts
{
  type: 'auction.start',
  payload: {
    taker: '0xTaker123...',
    wager: '1000000000000000000',
    predictions: [{
      resolverContract: '0xResolver456...',
      predictedOutcomes: '0xabc123',
    }],
    takerNonce: 1,
    chainId: 42161,
    marketContract: '0xPredictionMarket...'
  }
}
```

### bid.submit
```ts
{
  type: 'bid.submit',
  payload: {
    auctionId: 'c6b2d5bb-...-1f25',
    maker: '0xMaker789...',
    makerWager: '500000000000000000',
    makerDeadline: Math.floor(Date.now()/1000) + 60,
    makerSignature: '0x' + '11'.repeat(32) + '22'.repeat(32),
    makerNonce: 1
  }
}
```

## Implementation pointers

- See `packages/api/src/auction/botExample.ts` for a working maker reference
- Message and type definitions live in `packages/api/src/auction/types.ts`
- Server behavior: `ws.ts`, `registry.ts`, `sim.ts`, `helpers.ts`