---
title: "Auction Relayer API"
description: "Overview and integration notes for the Auction WebSocket."
---

# Auction Relayer API

The Auction WebSocket connects takers and makers for short-lived auctions. Takers announce an auction; makers submit bids; the relayer validates and forwards bids back to the taker.

- **Taker →** `auction.start` → relayer acks with `auction.ack` and broadcasts `auction.started`
- **Maker →** `bid.submit` → relayer acks with `bid.ack` and streams `auction.bids` to the taker

## Endpoints

- Production: `wss://api.sapience.xyz/auction` (confirm base URL)
- Local (monorepo): `ws://localhost:3001/auction`

## Quick start

### Minimal Taker flow (Node)
```ts
import WebSocket from 'ws';
const ws = new WebSocket('ws://localhost:3001/auction');

ws.on('open', () => {
  ws.send(JSON.stringify({
    type: 'auction.start',
    payload: {
      taker: '0xTaker123...',
      wager: '1000000000000000000',
      predictions: [{
        resolverContract: '0xResolver456...',
        predictedOutcome: '0xdeadbeef',
      }],
      takerNonce: 1,
      chainId: 42161,
      marketContract: '0xPredictionMarket...'
    },
  }));
});

ws.on('message', (data) => {
  const msg = JSON.parse(String(data));
  if (msg.type === 'auction.ack') {
    if (msg.payload.error) {
      console.error('auction.start rejected:', msg.payload.error);
      return;
    }
    console.log('started auctionId=', msg.payload.auctionId);
  }
  if (msg.type === 'auction.bids') {
    const bids = msg.payload.bids;
    // choose best non-expired by makerWager (highest first)
    bids.sort((a, b) => BigInt(b.makerWager) - BigInt(a.makerWager) > 0n ? 1 : -1);
    console.log('top bid:', bids[0]);
  }
});
```

### Minimal Maker flow (Browser/Node)
```ts
const ws = new WebSocket('ws://localhost:3001/auction');

ws.onmessage = (ev) => {
  const msg = JSON.parse(String(ev.data));
  if (msg.type === 'auction.started') {
    const auction = msg.payload;
    const now = Math.floor(Date.now()/1000);
    const bid = {
      type: 'bid.submit',
      payload: {
        auctionId: auction.auctionId,
        maker: '0xMaker789...',
        makerWager: (BigInt(auction.wager) / 2n).toString(),
        makerDeadline: now + 60,
        makerSignature: '0x...', // signature over typed payload (see Reference)
        makerNonce: 1
      }
    };
    ws.send(JSON.stringify(bid));
  }
};
```

## Message lifecycle

1) Taker sends `auction.start` with `taker`, `wager`, `predictions[]`, `takerNonce`, `chainId`, `marketContract`.
2) Relayer responds to the same socket with `auction.ack { auctionId?; error? }` and broadcasts `auction.started` (with the same payload plus `auctionId`) to all connected clients. The `auctionId` is a deterministic hash derived from the payload.
3) Makers send `bid.submit` with `auctionId`, `maker`, `makerWager`, `makerDeadline`, `makerSignature`, `makerNonce`.
4) Relayer replies to the bidding socket with `bid.ack { error? }` and streams `auction.bids { bids[] }` to the taker's subscribed socket for that auction.

- Makers are automatically subscribed to their auction’s channel upon `auction.start`.
- `auction.bids` is broadcast only to subscribers of that `auctionId`.
- Auctions are short-lived (about 60 seconds) and expire automatically.

## Validation (high level)

- **Auction**: positive `wager`, ≥1 `predictions`, each with `resolverContract` and non-empty `predictedOutcomes`; valid `taker` address and `chainId`, valid `marketContract`. Today only a single unique resolver is supported; otherwise `CROSS_VERIFIER_UNSUPPORTED`.
 - **Auction**: positive `wager`, ≥1 `predictions`, each with `resolverContract` and non-empty `predictedOutcome`; valid `taker` address and `chainId`, valid `marketContract`. Today only a single unique resolver is supported; otherwise `CROSS_VERIFIER_UNSUPPORTED`.
- **Bid**: `makerDeadline` in the future, positive `makerWager`, valid hex `makerSignature` format
- Optional strict signature verification uses EIP-712 with domain `{ chainId: auction.chainId, verifyingContract: auction.marketContract }` and inner hash over `predictionsHash`, `makerWager`, `makerDeadline` (see Reference).

## Limits and closes

- Rate limit: 100 messages per 10s window; violations close with code `1008` and reason `rate_limited`
- Max message size: 64,000 bytes; violations close with code `1009` and reason `message_too_large`

## Selecting the best bid

Relayer keeps all valid bids for the auction. The UI or taker should select the best non-expired bid, typically the highest `makerWager`.

## Next steps

- Read the full message schemas and typed-signature details in the Reference: [Auction Relayer Reference](/builder-guide/reference/auction-relayer)
- See a working maker bot in `packages/api/src/auction/botExample.ts` for practical integration patterns.

