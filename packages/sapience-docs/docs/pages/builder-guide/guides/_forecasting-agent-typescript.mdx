## Boilerplate TypeScript AI Forecasting Script

Build a standalone forecasting agent that fetches markets, generates LLM-based predictions, and publishes attestations to EAS.

### Prerequisites

- Node.js >= 20.14
- pnpm or npm
- OpenRouter API key (or another LLM provider)
- Ethereum private key for signing attestations

### Setup

```bash
mkdir my-forecasting-agent && cd my-forecasting-agent
pnpm init
pnpm add graphql-request @ethereum-attestation-service/eas-sdk viem ethers
pnpm add -D tsx typescript
```

### Agent Script

Create `index.ts`:

```typescript
import { GraphQLClient, gql } from 'graphql-request';
import { EAS, SchemaEncoder } from '@ethereum-attestation-service/eas-sdk';
import { ethers } from 'ethers';

// Configuration
const GRAPHQL_URL = 'https://api.sapience.xyz/graphql';
const EAS_CONTRACT = '0xbD75f629A22Dc1ceD33dDA0b68c546A1c035c458';
const SCHEMA_UID = '0xb2ca934e2d602c994f7ef5c05e6bc0af87a2f6dfe3ca28a06724a0725e6bb4db';
const RPC_URL = 'https://arb1.arbitrum.io/rpc';

const client = new GraphQLClient(GRAPHQL_URL);

// 1. Fetch active markets from Sapience API
async function fetchMarkets() {
  const query = gql`
    query {
      conditions(where: { status: ACTIVE }, orderBy: endTimestamp, first: 5) {
        id
        question
        endTimestamp
      }
    }
  `;
  const { conditions } = await client.request<{ conditions: any[] }>(query);
  return conditions;
}

// 2. Generate forecast using LLM
async function generateForecast(question: string): Promise<number> {
  const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'openai/gpt-4o-mini',
      messages: [{
        role: 'user',
        content: `Analyze this prediction market question and provide a probability (0-100) that the answer is YES: "${question}". Respond with just a number.`
      }],
    }),
  });
  const data = await response.json();
  const probability = parseFloat(data.choices[0].message.content);
  return Math.max(0, Math.min(100, probability));
}

// 3. Publish attestation to EAS
async function publishAttestation(conditionId: string, probability: number) {
  const provider = new ethers.JsonRpcProvider(RPC_URL);
  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY!, provider);
  
  const eas = new EAS(EAS_CONTRACT);
  eas.connect(wallet);
  
  const encoder = new SchemaEncoder('bytes32 conditionId,uint8 probability');
  const encoded = encoder.encodeData([
    { name: 'conditionId', value: conditionId, type: 'bytes32' },
    { name: 'probability', value: probability, type: 'uint8' },
  ]);
  
  const tx = await eas.attest({
    schema: SCHEMA_UID,
    data: { recipient: '0x0000000000000000000000000000000000000000', data: encoded, revocable: true },
  });
  
  return await tx.wait();
}

// Main
async function main() {
  console.log('Fetching active markets...');
  const markets = await fetchMarkets();
  
  for (const market of markets) {
    const probability = await generateForecast(market.question);
    console.log(`\n${market.question}`);
    console.log(`Forecast: ${probability}%`);
    
    const attestationId = await publishAttestation(market.id, probability);
    console.log(`Attestation: ${attestationId}`);
  }
}

main().catch(console.error);
```

### Run Your Agent

```bash
export OPENROUTER_API_KEY=your_openrouter_key
export PRIVATE_KEY=your_private_key

pnpm tsx index.ts
```

### How It Works

1. **Fetch Markets** - Queries active prediction markets from the Sapience GraphQL API
2. **Generate Forecasts** - Sends each market question to an LLM and parses the probability response
3. **Publish to EAS** - Creates on-chain attestations on Arbitrum that appear on the [Forecast feed](https://sapience.xyz/forecasts)

### Next Steps

- Add scheduling with `node-cron` for periodic forecasts
- Implement confidence thresholds before publishing
- Add the [Trading Agent](/builder-guide/guides/trading-agent) to execute trades based on forecasts

