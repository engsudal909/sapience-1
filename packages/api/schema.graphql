# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AccuracyRankType {
  accuracyScore: Float!
  attester: String!
  rank: Int
  totalForecasters: Int!
}

type AggregateAttestation {
  _avg: AttestationAvgAggregate
  _count: AttestationCountAggregate
  _max: AttestationMaxAggregate
  _min: AttestationMinAggregate
  _sum: AttestationSumAggregate
}

type AggregateCategory {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
}

type AggregateCondition {
  _avg: ConditionAvgAggregate
  _count: ConditionCountAggregate
  _max: ConditionMaxAggregate
  _min: ConditionMinAggregate
  _sum: ConditionSumAggregate
}

type AggregateMarket {
  _avg: MarketAvgAggregate
  _count: MarketCountAggregate
  _max: MarketMaxAggregate
  _min: MarketMinAggregate
  _sum: MarketSumAggregate
}

type AggregateMarketGroup {
  _avg: MarketGroupAvgAggregate
  _count: MarketGroupCountAggregate
  _max: MarketGroupMaxAggregate
  _min: MarketGroupMinAggregate
  _sum: MarketGroupSumAggregate
}

type AggregateMarketPrice {
  _avg: MarketPriceAvgAggregate
  _count: MarketPriceCountAggregate
  _max: MarketPriceMaxAggregate
  _min: MarketPriceMinAggregate
  _sum: MarketPriceSumAggregate
}

type AggregatePosition {
  _avg: PositionAvgAggregate
  _count: PositionCountAggregate
  _max: PositionMaxAggregate
  _min: PositionMinAggregate
  _sum: PositionSumAggregate
}

type AggregateResource {
  _avg: ResourceAvgAggregate
  _count: ResourceCountAggregate
  _max: ResourceMaxAggregate
  _min: ResourceMinAggregate
  _sum: ResourceSumAggregate
}

type AggregateResourcePrice {
  _avg: ResourcePriceAvgAggregate
  _count: ResourcePriceCountAggregate
  _max: ResourcePriceMaxAggregate
  _min: ResourcePriceMinAggregate
  _sum: ResourcePriceSumAggregate
}

type AggregateTransaction {
  _avg: TransactionAvgAggregate
  _count: TransactionCountAggregate
  _max: TransactionMaxAggregate
  _min: TransactionMinAggregate
  _sum: TransactionSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type AggregatedProfitEntryType {
  owner: String!
  totalPnL: Float!
}

type Attestation {
  attestation_score(where: AttestationScoreWhereInput): AttestationScore
  attester: String!
  blockNumber: Int!
  comment: String
  createdAt: DateTimeISO!
  data: String!
  decodedDataJson: String!
  id: Int!
  marketAddress: String!
  marketId: String!
  prediction: String!
  questionId: String!
  recipient: String!
  schemaId: String!
  time: Int!
  transactionHash: String!
  uid: String!
}

type AttestationAvgAggregate {
  blockNumber: Float
  id: Float
  time: Float
}

input AttestationAvgOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  time: SortOrder
}

type AttestationCountAggregate {
  _all: Int!
  attester: Int!
  blockNumber: Int!
  comment: Int!
  createdAt: Int!
  data: Int!
  decodedDataJson: Int!
  id: Int!
  marketAddress: Int!
  marketId: Int!
  prediction: Int!
  questionId: Int!
  recipient: Int!
  schemaId: Int!
  time: Int!
  transactionHash: Int!
  uid: Int!
}

input AttestationCountOrderByAggregateInput {
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrder
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

type AttestationGroupBy {
  _avg: AttestationAvgAggregate
  _count: AttestationCountAggregate
  _max: AttestationMaxAggregate
  _min: AttestationMinAggregate
  _sum: AttestationSumAggregate
  attester: String!
  blockNumber: Int!
  comment: String
  createdAt: DateTimeISO!
  data: String!
  decodedDataJson: String!
  id: Int!
  marketAddress: String!
  marketId: String!
  prediction: String!
  questionId: String!
  recipient: String!
  schemaId: String!
  time: Int!
  transactionHash: String!
  uid: String!
}

type AttestationMaxAggregate {
  attester: String
  blockNumber: Int
  comment: String
  createdAt: DateTimeISO
  data: String
  decodedDataJson: String
  id: Int
  marketAddress: String
  marketId: String
  prediction: String
  questionId: String
  recipient: String
  schemaId: String
  time: Int
  transactionHash: String
  uid: String
}

input AttestationMaxOrderByAggregateInput {
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrder
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

type AttestationMinAggregate {
  attester: String
  blockNumber: Int
  comment: String
  createdAt: DateTimeISO
  data: String
  decodedDataJson: String
  id: Int
  marketAddress: String
  marketId: String
  prediction: String
  questionId: String
  recipient: String
  schemaId: String
  time: Int
  transactionHash: String
  uid: String
}

input AttestationMinOrderByAggregateInput {
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrder
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

input AttestationOrderByWithAggregationInput {
  _avg: AttestationAvgOrderByAggregateInput
  _count: AttestationCountOrderByAggregateInput
  _max: AttestationMaxOrderByAggregateInput
  _min: AttestationMinOrderByAggregateInput
  _sum: AttestationSumOrderByAggregateInput
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrderInput
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

input AttestationOrderByWithRelationInput {
  attestation_score: AttestationScoreOrderByWithRelationInput
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrderInput
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

input AttestationRelationFilter {
  is: AttestationWhereInput
  isNot: AttestationWhereInput
}

enum AttestationScalarFieldEnum {
  attester
  blockNumber
  comment
  createdAt
  data
  decodedDataJson
  id
  marketAddress
  marketId
  prediction
  questionId
  recipient
  schemaId
  time
  transactionHash
  uid
}

input AttestationScalarWhereWithAggregatesInput {
  AND: [AttestationScalarWhereWithAggregatesInput!]
  NOT: [AttestationScalarWhereWithAggregatesInput!]
  OR: [AttestationScalarWhereWithAggregatesInput!]
  attester: StringWithAggregatesFilter
  blockNumber: IntWithAggregatesFilter
  comment: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  data: StringWithAggregatesFilter
  decodedDataJson: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  marketAddress: StringWithAggregatesFilter
  marketId: StringWithAggregatesFilter
  prediction: StringWithAggregatesFilter
  questionId: StringWithAggregatesFilter
  recipient: StringWithAggregatesFilter
  schemaId: StringWithAggregatesFilter
  time: IntWithAggregatesFilter
  transactionHash: StringWithAggregatesFilter
  uid: StringWithAggregatesFilter
}

type AttestationScore {
  attestation: Attestation!
  attestationId: Int!
  attester: String!
  createdAt: DateTimeISO!
  errorSquared: Float
  id: Int!
  madeAt: Int!
  marketAddress: String!
  marketId: String!
  outcome: Int
  probabilityD18: String
  probabilityFloat: Float
  questionId: String
  scoredAt: DateTimeISO
  used: Boolean!
}

input AttestationScoreNullableRelationFilter {
  is: AttestationScoreWhereInput
  isNot: AttestationScoreWhereInput
}

input AttestationScoreOrderByWithRelationInput {
  attestation: AttestationOrderByWithRelationInput
  attestationId: SortOrder
  attester: SortOrder
  createdAt: SortOrder
  errorSquared: SortOrderInput
  id: SortOrder
  madeAt: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  outcome: SortOrderInput
  probabilityD18: SortOrderInput
  probabilityFloat: SortOrderInput
  questionId: SortOrderInput
  scoredAt: SortOrderInput
  used: SortOrder
}

input AttestationScoreWhereInput {
  AND: [AttestationScoreWhereInput!]
  NOT: [AttestationScoreWhereInput!]
  OR: [AttestationScoreWhereInput!]
  attestation: AttestationRelationFilter
  attestationId: IntFilter
  attester: StringFilter
  createdAt: DateTimeFilter
  errorSquared: FloatNullableFilter
  id: IntFilter
  madeAt: IntFilter
  marketAddress: StringFilter
  marketId: StringFilter
  outcome: IntNullableFilter
  probabilityD18: StringNullableFilter
  probabilityFloat: FloatNullableFilter
  questionId: StringNullableFilter
  scoredAt: DateTimeNullableFilter
  used: BoolFilter
}

type AttestationSumAggregate {
  blockNumber: Int
  id: Int
  time: Int
}

input AttestationSumOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  time: SortOrder
}

input AttestationWhereInput {
  AND: [AttestationWhereInput!]
  NOT: [AttestationWhereInput!]
  OR: [AttestationWhereInput!]
  attestation_score: AttestationScoreNullableRelationFilter
  attester: StringFilter
  blockNumber: IntFilter
  comment: StringNullableFilter
  createdAt: DateTimeFilter
  data: StringFilter
  decodedDataJson: StringFilter
  id: IntFilter
  marketAddress: StringFilter
  marketId: StringFilter
  prediction: StringFilter
  questionId: StringFilter
  recipient: StringFilter
  schemaId: StringFilter
  time: IntFilter
  transactionHash: StringFilter
  uid: StringFilter
}

input AttestationWhereUniqueInput {
  AND: [AttestationWhereInput!]
  NOT: [AttestationWhereInput!]
  OR: [AttestationWhereInput!]
  attestation_score: AttestationScoreNullableRelationFilter
  attester: StringFilter
  blockNumber: IntFilter
  comment: StringNullableFilter
  createdAt: DateTimeFilter
  data: StringFilter
  decodedDataJson: StringFilter
  id: Int
  marketAddress: StringFilter
  marketId: StringFilter
  prediction: StringFilter
  questionId: StringFilter
  recipient: StringFilter
  schemaId: StringFilter
  time: IntFilter
  transactionHash: StringFilter
  uid: String
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input BigIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedBigIntFilter
  _min: NestedBigIntFilter
  _sum: NestedBigIntFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntWithAggregatesFilter
  notIn: [BigInt!]
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input BoolNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBoolNullableFilter
  _min: NestedBoolNullableFilter
  equals: Boolean
  not: NestedBoolNullableWithAggregatesFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type CandleAndTimestampType {
  data: [CandleType!]!
  lastUpdateTimestamp: Int!
}

type CandleType {
  close: String!
  high: String!
  low: String!
  open: String!
  timestamp: Int!
}

type Category {
  _count: CategoryCount
  conditions(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): [Condition!]!
  createdAt: DateTimeISO!
  id: Int!
  marketGroups(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroup!]!
  name: String!
  resources(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): [Resource!]!
  slug: String!
}

type CategoryAvgAggregate {
  id: Float
}

input CategoryAvgOrderByAggregateInput {
  id: SortOrder
}

type CategoryCount {
  condition(where: ConditionWhereInput): Int!
  market_group(where: MarketGroupWhereInput): Int!
  resource(where: ResourceWhereInput): Int!
}

type CategoryCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  slug: Int!
}

input CategoryCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type CategoryGroupBy {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
  createdAt: DateTimeISO!
  id: Int!
  name: String!
  slug: String!
}

type CategoryMaxAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input CategoryMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type CategoryMinAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input CategoryMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryNullableRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryOrderByWithRelationInput {
  conditions: ConditionOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  marketGroups: MarketGroupOrderByRelationAggregateInput
  name: SortOrder
  resources: ResourceOrderByRelationAggregateInput
  slug: SortOrder
}

enum CategoryScalarFieldEnum {
  createdAt
  id
  name
  slug
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

type CategorySumAggregate {
  id: Int
}

input CategorySumOrderByAggregateInput {
  id: SortOrder
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  conditions: ConditionListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  marketGroups: MarketGroupListRelationFilter
  name: StringFilter
  resources: ResourceListRelationFilter
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  conditions: ConditionListRelationFilter
  createdAt: DateTimeFilter
  id: Int
  marketGroups: MarketGroupListRelationFilter
  name: String
  resources: ResourceListRelationFilter
  slug: String
}

type CollateralTransfer {
  collateral: String!
  createdAt: DateTimeISO!
  id: Int!
  owner: String!
  timestamp: Int!
  transaction(where: TransactionWhereInput): Transaction
  transactionHash: String!
}

input CollateralTransferNullableRelationFilter {
  is: CollateralTransferWhereInput
  isNot: CollateralTransferWhereInput
}

input CollateralTransferOrderByWithRelationInput {
  collateral: SortOrder
  createdAt: SortOrder
  id: SortOrder
  owner: SortOrder
  timestamp: SortOrder
  transaction: TransactionOrderByWithRelationInput
  transactionHash: SortOrder
}

input CollateralTransferWhereInput {
  AND: [CollateralTransferWhereInput!]
  NOT: [CollateralTransferWhereInput!]
  OR: [CollateralTransferWhereInput!]
  collateral: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  owner: StringFilter
  timestamp: IntFilter
  transaction: TransactionNullableRelationFilter
  transactionHash: StringFilter
}

type Condition {
  category(where: CategoryWhereInput): Category
  categoryId: Int
  chainId: Int!
  claimStatement: String!
  createdAt: DateTimeISO!
  description: String!
  endTime: Int!
  id: String!
  public: Boolean!
  question: String!
  shortName: String
  similarMarkets: [String!]!
}

type ConditionAvgAggregate {
  categoryId: Float
  chainId: Float
  endTime: Float
}

input ConditionAvgOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  endTime: SortOrder
}

type ConditionCountAggregate {
  _all: Int!
  categoryId: Int!
  chainId: Int!
  claimStatement: Int!
  createdAt: Int!
  description: Int!
  endTime: Int!
  id: Int!
  public: Int!
  question: Int!
  shortName: Int!
  similarMarkets: Int!
}

input ConditionCountOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  claimStatement: SortOrder
  createdAt: SortOrder
  description: SortOrder
  endTime: SortOrder
  id: SortOrder
  public: SortOrder
  question: SortOrder
  shortName: SortOrder
  similarMarkets: SortOrder
}

type ConditionGroupBy {
  _avg: ConditionAvgAggregate
  _count: ConditionCountAggregate
  _max: ConditionMaxAggregate
  _min: ConditionMinAggregate
  _sum: ConditionSumAggregate
  categoryId: Int
  chainId: Int!
  claimStatement: String!
  createdAt: DateTimeISO!
  description: String!
  endTime: Int!
  id: String!
  public: Boolean!
  question: String!
  shortName: String
  similarMarkets: [String!]
}

input ConditionListRelationFilter {
  every: ConditionWhereInput
  none: ConditionWhereInput
  some: ConditionWhereInput
}

type ConditionMaxAggregate {
  categoryId: Int
  chainId: Int
  claimStatement: String
  createdAt: DateTimeISO
  description: String
  endTime: Int
  id: String
  public: Boolean
  question: String
  shortName: String
}

input ConditionMaxOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  claimStatement: SortOrder
  createdAt: SortOrder
  description: SortOrder
  endTime: SortOrder
  id: SortOrder
  public: SortOrder
  question: SortOrder
  shortName: SortOrder
}

type ConditionMinAggregate {
  categoryId: Int
  chainId: Int
  claimStatement: String
  createdAt: DateTimeISO
  description: String
  endTime: Int
  id: String
  public: Boolean
  question: String
  shortName: String
}

input ConditionMinOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  claimStatement: SortOrder
  createdAt: SortOrder
  description: SortOrder
  endTime: SortOrder
  id: SortOrder
  public: SortOrder
  question: SortOrder
  shortName: SortOrder
}

input ConditionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ConditionOrderByWithAggregationInput {
  _avg: ConditionAvgOrderByAggregateInput
  _count: ConditionCountOrderByAggregateInput
  _max: ConditionMaxOrderByAggregateInput
  _min: ConditionMinOrderByAggregateInput
  _sum: ConditionSumOrderByAggregateInput
  categoryId: SortOrderInput
  chainId: SortOrder
  claimStatement: SortOrder
  createdAt: SortOrder
  description: SortOrder
  endTime: SortOrder
  id: SortOrder
  public: SortOrder
  question: SortOrder
  shortName: SortOrderInput
  similarMarkets: SortOrder
}

input ConditionOrderByWithRelationInput {
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrderInput
  chainId: SortOrder
  claimStatement: SortOrder
  createdAt: SortOrder
  description: SortOrder
  endTime: SortOrder
  id: SortOrder
  public: SortOrder
  question: SortOrder
  shortName: SortOrderInput
  similarMarkets: SortOrder
}

enum ConditionScalarFieldEnum {
  categoryId
  chainId
  claimStatement
  createdAt
  description
  endTime
  id
  public
  question
  shortName
  similarMarkets
}

input ConditionScalarWhereWithAggregatesInput {
  AND: [ConditionScalarWhereWithAggregatesInput!]
  NOT: [ConditionScalarWhereWithAggregatesInput!]
  OR: [ConditionScalarWhereWithAggregatesInput!]
  categoryId: IntNullableWithAggregatesFilter
  chainId: IntWithAggregatesFilter
  claimStatement: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  endTime: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  public: BoolWithAggregatesFilter
  question: StringWithAggregatesFilter
  shortName: StringNullableWithAggregatesFilter
  similarMarkets: StringNullableListFilter
}

type ConditionSumAggregate {
  categoryId: Int
  chainId: Int
  endTime: Int
}

input ConditionSumOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  endTime: SortOrder
}

type ConditionSummary {
  endTime: Int
  id: String!
  question: String
  shortName: String
}

input ConditionWhereInput {
  AND: [ConditionWhereInput!]
  NOT: [ConditionWhereInput!]
  OR: [ConditionWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  claimStatement: StringFilter
  createdAt: DateTimeFilter
  description: StringFilter
  endTime: IntFilter
  id: StringFilter
  public: BoolFilter
  question: StringFilter
  shortName: StringNullableFilter
  similarMarkets: StringNullableListFilter
}

input ConditionWhereUniqueInput {
  AND: [ConditionWhereInput!]
  NOT: [ConditionWhereInput!]
  OR: [ConditionWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  claimStatement: StringFilter
  createdAt: DateTimeFilter
  description: StringFilter
  endTime: IntFilter
  id: String
  public: BoolFilter
  question: StringFilter
  shortName: StringNullableFilter
  similarMarkets: StringNullableListFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

"""
GraphQL Scalar representing the Prisma.Decimal type, based on Decimal.js library.
"""
scalar Decimal

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input DecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input DecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input DecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input Enumtransaction_type_enumFilter {
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumFilter
  notIn: [transaction_type_enum!]
}

input Enumtransaction_type_enumWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumtransaction_type_enumFilter
  _min: NestedEnumtransaction_type_enumFilter
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumWithAggregatesFilter
  notIn: [transaction_type_enum!]
}

type Event {
  blockNumber: Int!
  createdAt: DateTimeISO!
  id: Int!
  logData: JSON!
  logIndex: Int!
  marketGroup(where: MarketGroupWhereInput): MarketGroup
  marketGroupId: Int
  timestamp: BigInt!
  transaction(where: TransactionWhereInput): Transaction
  transactionHash: String!
}

input EventListRelationFilter {
  every: EventWhereInput
  none: EventWhereInput
  some: EventWhereInput
}

input EventNullableRelationFilter {
  is: EventWhereInput
  isNot: EventWhereInput
}

input EventOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventOrderByWithRelationInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  id: SortOrder
  logData: SortOrder
  logIndex: SortOrder
  marketGroup: MarketGroupOrderByWithRelationInput
  marketGroupId: SortOrderInput
  timestamp: SortOrder
  transaction: TransactionOrderByWithRelationInput
  transactionHash: SortOrder
}

enum EventScalarFieldEnum {
  blockNumber
  createdAt
  id
  logData
  logIndex
  marketGroupId
  timestamp
  transactionHash
}

input EventTransactionHashMarketGroupIdBlockNumberLogIndexCompoundUniqueInput {
  blockNumber: Int!
  logIndex: Int!
  marketGroupId: Int!
  transactionHash: String!
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  logData: JsonFilter
  logIndex: IntFilter
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  transactionHash: StringFilter
}

input EventWhereUniqueInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  id: Int
  logData: JsonFilter
  logIndex: IntFilter
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  transactionHash: StringFilter
  transactionHash_marketGroupId_blockNumber_logIndex: EventTransactionHashMarketGroupIdBlockNumberLogIndexCompoundUniqueInput
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

type ForecasterScoreType {
  accuracyScore: Float!
  attester: String!
  numScored: Int!
  numTimeWeighted: Int!
  sumErrorSquared: Float!
  sumTimeWeightedError: Float!
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Market {
  _count: MarketCount
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  claimStatementNo: String
  claimStatementYesOrNumeric: String
  createdAt: DateTimeISO!
  endTimestamp: Int
  id: Int!
  marketGroup(where: MarketGroupWhereInput): MarketGroup
  marketGroupId: Int
  marketId: Int!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  positions(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): [Position!]!
  public: Boolean!
  question: String
  settled: Boolean
  settledAt: Int
  settlementPriceD18: Decimal
  shortName: String
  similarMarkets: [String!]!
  startTimestamp: Int
  startingSqrtPriceX96: String
}

type MarketAvgAggregate {
  baseAssetMaxPriceTick: Float
  baseAssetMinPriceTick: Float
  endTimestamp: Float
  id: Float
  marketGroupId: Float
  marketId: Float
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Float
  maxPriceD18: Decimal
  minPriceD18: Decimal
  settledAt: Float
  settlementPriceD18: Decimal
  startTimestamp: Float
}

input MarketAvgOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  settledAt: SortOrder
  settlementPriceD18: SortOrder
  startTimestamp: SortOrder
}

type MarketCount {
  position(where: PositionWhereInput): Int!
}

type MarketCountAggregate {
  _all: Int!
  baseAssetMaxPriceTick: Int!
  baseAssetMinPriceTick: Int!
  claimStatementNo: Int!
  claimStatementYesOrNumeric: Int!
  createdAt: Int!
  endTimestamp: Int!
  id: Int!
  marketGroupId: Int!
  marketId: Int!
  marketParamsAssertionliveness: Int!
  marketParamsBondamount: Int!
  marketParamsBondcurrency: Int!
  marketParamsFeerate: Int!
  marketParamsOptimisticoraclev3: Int!
  marketParamsUniswappositionmanager: Int!
  marketParamsUniswapquoter: Int!
  marketParamsUniswapswaprouter: Int!
  maxPriceD18: Int!
  minPriceD18: Int!
  optionName: Int!
  poolAddress: Int!
  public: Int!
  question: Int!
  settled: Int!
  settledAt: Int!
  settlementPriceD18: Int!
  shortName: Int!
  similarMarkets: Int!
  startTimestamp: Int!
  startingSqrtPriceX96: Int!
}

input MarketCountOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  claimStatementNo: SortOrder
  claimStatementYesOrNumeric: SortOrder
  createdAt: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  optionName: SortOrder
  poolAddress: SortOrder
  public: SortOrder
  question: SortOrder
  settled: SortOrder
  settledAt: SortOrder
  settlementPriceD18: SortOrder
  shortName: SortOrder
  similarMarkets: SortOrder
  startTimestamp: SortOrder
  startingSqrtPriceX96: SortOrder
}

type MarketGroup {
  _count: MarketGroupCount
  address: String
  baseTokenName: String
  category(where: CategoryWhereInput): Category
  categoryId: Int
  chainId: Int!
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO!
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByWithRelationInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
  factoryAddress: String
  id: Int!
  initializationNonce: String
  isBridged: Boolean!
  isCumulative: Boolean!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  markets(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): [Market!]!
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resource(where: ResourceWhereInput): Resource
  resourceId: Int
  rules: String
}

input MarketGroupAddressChainIdCompoundUniqueInput {
  address: String!
  chainId: Int!
}

type MarketGroupAvgAggregate {
  categoryId: Float
  chainId: Float
  collateralDecimals: Float
  deployTimestamp: Float
  deployTxnBlockNumber: Float
  id: Float
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Float
  minTradeSize: Decimal
  resourceId: Float
}

input MarketGroupAvgOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  collateralDecimals: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  id: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  minTradeSize: SortOrder
  resourceId: SortOrder
}

type MarketGroupBy {
  _avg: MarketAvgAggregate
  _count: MarketCountAggregate
  _max: MarketMaxAggregate
  _min: MarketMinAggregate
  _sum: MarketSumAggregate
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  claimStatementNo: String
  claimStatementYesOrNumeric: String
  createdAt: DateTimeISO!
  endTimestamp: Int
  id: Int!
  marketGroupId: Int
  marketId: Int!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  public: Boolean!
  question: String
  settled: Boolean
  settledAt: Int
  settlementPriceD18: Decimal
  shortName: String
  similarMarkets: [String!]
  startTimestamp: Int
  startingSqrtPriceX96: String
}

type MarketGroupCount {
  event(where: EventWhereInput): Int!
  market(where: MarketWhereInput): Int!
}

type MarketGroupCountAggregate {
  _all: Int!
  address: Int!
  baseTokenName: Int!
  categoryId: Int!
  chainId: Int!
  collateralAsset: Int!
  collateralDecimals: Int!
  collateralSymbol: Int!
  createdAt: Int!
  deployTimestamp: Int!
  deployTxnBlockNumber: Int!
  factoryAddress: Int!
  id: Int!
  initializationNonce: Int!
  isBridged: Int!
  isCumulative: Int!
  marketParamsAssertionliveness: Int!
  marketParamsBondamount: Int!
  marketParamsBondcurrency: Int!
  marketParamsFeerate: Int!
  marketParamsOptimisticoraclev3: Int!
  marketParamsUniswappositionmanager: Int!
  marketParamsUniswapquoter: Int!
  marketParamsUniswapswaprouter: Int!
  minTradeSize: Int!
  owner: Int!
  question: Int!
  quoteTokenName: Int!
  resourceId: Int!
  rules: Int!
}

input MarketGroupCountOrderByAggregateInput {
  address: SortOrder
  baseTokenName: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  collateralAsset: SortOrder
  collateralDecimals: SortOrder
  collateralSymbol: SortOrder
  createdAt: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  factoryAddress: SortOrder
  id: SortOrder
  initializationNonce: SortOrder
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  minTradeSize: SortOrder
  owner: SortOrder
  question: SortOrder
  quoteTokenName: SortOrder
  resourceId: SortOrder
  rules: SortOrder
}

type MarketGroupGroupBy {
  _avg: MarketGroupAvgAggregate
  _count: MarketGroupCountAggregate
  _max: MarketGroupMaxAggregate
  _min: MarketGroupMinAggregate
  _sum: MarketGroupSumAggregate
  address: String
  baseTokenName: String
  categoryId: Int
  chainId: Int!
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO!
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  factoryAddress: String
  id: Int!
  initializationNonce: String
  isBridged: Boolean!
  isCumulative: Boolean!
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resourceId: Int
  rules: String
}

input MarketGroupListRelationFilter {
  every: MarketGroupWhereInput
  none: MarketGroupWhereInput
  some: MarketGroupWhereInput
}

type MarketGroupMaxAggregate {
  address: String
  baseTokenName: String
  categoryId: Int
  chainId: Int
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  factoryAddress: String
  id: Int
  initializationNonce: String
  isBridged: Boolean
  isCumulative: Boolean
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resourceId: Int
  rules: String
}

input MarketGroupMaxOrderByAggregateInput {
  address: SortOrder
  baseTokenName: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  collateralAsset: SortOrder
  collateralDecimals: SortOrder
  collateralSymbol: SortOrder
  createdAt: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  factoryAddress: SortOrder
  id: SortOrder
  initializationNonce: SortOrder
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  minTradeSize: SortOrder
  owner: SortOrder
  question: SortOrder
  quoteTokenName: SortOrder
  resourceId: SortOrder
  rules: SortOrder
}

type MarketGroupMinAggregate {
  address: String
  baseTokenName: String
  categoryId: Int
  chainId: Int
  collateralAsset: String
  collateralDecimals: Int
  collateralSymbol: String
  createdAt: DateTimeISO
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  factoryAddress: String
  id: Int
  initializationNonce: String
  isBridged: Boolean
  isCumulative: Boolean
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  minTradeSize: Decimal
  owner: String
  question: String
  quoteTokenName: String
  resourceId: Int
  rules: String
}

input MarketGroupMinOrderByAggregateInput {
  address: SortOrder
  baseTokenName: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  collateralAsset: SortOrder
  collateralDecimals: SortOrder
  collateralSymbol: SortOrder
  createdAt: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  factoryAddress: SortOrder
  id: SortOrder
  initializationNonce: SortOrder
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  minTradeSize: SortOrder
  owner: SortOrder
  question: SortOrder
  quoteTokenName: SortOrder
  resourceId: SortOrder
  rules: SortOrder
}

input MarketGroupNullableRelationFilter {
  is: MarketGroupWhereInput
  isNot: MarketGroupWhereInput
}

input MarketGroupOrderByRelationAggregateInput {
  _count: SortOrder
}

input MarketGroupOrderByWithAggregationInput {
  _avg: MarketGroupAvgOrderByAggregateInput
  _count: MarketGroupCountOrderByAggregateInput
  _max: MarketGroupMaxOrderByAggregateInput
  _min: MarketGroupMinOrderByAggregateInput
  _sum: MarketGroupSumOrderByAggregateInput
  address: SortOrderInput
  baseTokenName: SortOrderInput
  categoryId: SortOrderInput
  chainId: SortOrder
  collateralAsset: SortOrderInput
  collateralDecimals: SortOrderInput
  collateralSymbol: SortOrderInput
  createdAt: SortOrder
  deployTimestamp: SortOrderInput
  deployTxnBlockNumber: SortOrderInput
  factoryAddress: SortOrderInput
  id: SortOrder
  initializationNonce: SortOrderInput
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  minTradeSize: SortOrderInput
  owner: SortOrderInput
  question: SortOrderInput
  quoteTokenName: SortOrderInput
  resourceId: SortOrderInput
  rules: SortOrderInput
}

input MarketGroupOrderByWithRelationInput {
  address: SortOrderInput
  baseTokenName: SortOrderInput
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrderInput
  chainId: SortOrder
  collateralAsset: SortOrderInput
  collateralDecimals: SortOrderInput
  collateralSymbol: SortOrderInput
  createdAt: SortOrder
  deployTimestamp: SortOrderInput
  deployTxnBlockNumber: SortOrderInput
  events: EventOrderByRelationAggregateInput
  factoryAddress: SortOrderInput
  id: SortOrder
  initializationNonce: SortOrderInput
  isBridged: SortOrder
  isCumulative: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  markets: MarketOrderByRelationAggregateInput
  minTradeSize: SortOrderInput
  owner: SortOrderInput
  question: SortOrderInput
  quoteTokenName: SortOrderInput
  resource: ResourceOrderByWithRelationInput
  resourceId: SortOrderInput
  rules: SortOrderInput
}

enum MarketGroupScalarFieldEnum {
  address
  baseTokenName
  categoryId
  chainId
  collateralAsset
  collateralDecimals
  collateralSymbol
  createdAt
  deployTimestamp
  deployTxnBlockNumber
  factoryAddress
  id
  initializationNonce
  isBridged
  isCumulative
  marketParamsAssertionliveness
  marketParamsBondamount
  marketParamsBondcurrency
  marketParamsFeerate
  marketParamsOptimisticoraclev3
  marketParamsUniswappositionmanager
  marketParamsUniswapquoter
  marketParamsUniswapswaprouter
  minTradeSize
  owner
  question
  quoteTokenName
  resourceId
  rules
}

input MarketGroupScalarWhereWithAggregatesInput {
  AND: [MarketGroupScalarWhereWithAggregatesInput!]
  NOT: [MarketGroupScalarWhereWithAggregatesInput!]
  OR: [MarketGroupScalarWhereWithAggregatesInput!]
  address: StringNullableWithAggregatesFilter
  baseTokenName: StringNullableWithAggregatesFilter
  categoryId: IntNullableWithAggregatesFilter
  chainId: IntWithAggregatesFilter
  collateralAsset: StringNullableWithAggregatesFilter
  collateralDecimals: IntNullableWithAggregatesFilter
  collateralSymbol: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  deployTimestamp: IntNullableWithAggregatesFilter
  deployTxnBlockNumber: IntNullableWithAggregatesFilter
  factoryAddress: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  initializationNonce: StringNullableWithAggregatesFilter
  isBridged: BoolWithAggregatesFilter
  isCumulative: BoolWithAggregatesFilter
  marketParamsAssertionliveness: DecimalNullableWithAggregatesFilter
  marketParamsBondamount: DecimalNullableWithAggregatesFilter
  marketParamsBondcurrency: StringNullableWithAggregatesFilter
  marketParamsFeerate: IntNullableWithAggregatesFilter
  marketParamsOptimisticoraclev3: StringNullableWithAggregatesFilter
  marketParamsUniswappositionmanager: StringNullableWithAggregatesFilter
  marketParamsUniswapquoter: StringNullableWithAggregatesFilter
  marketParamsUniswapswaprouter: StringNullableWithAggregatesFilter
  minTradeSize: DecimalNullableWithAggregatesFilter
  owner: StringNullableWithAggregatesFilter
  question: StringNullableWithAggregatesFilter
  quoteTokenName: StringNullableWithAggregatesFilter
  resourceId: IntNullableWithAggregatesFilter
  rules: StringNullableWithAggregatesFilter
}

type MarketGroupSumAggregate {
  categoryId: Int
  chainId: Int
  collateralDecimals: Int
  deployTimestamp: Int
  deployTxnBlockNumber: Int
  id: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Int
  minTradeSize: Decimal
  resourceId: Int
}

input MarketGroupSumOrderByAggregateInput {
  categoryId: SortOrder
  chainId: SortOrder
  collateralDecimals: SortOrder
  deployTimestamp: SortOrder
  deployTxnBlockNumber: SortOrder
  id: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  minTradeSize: SortOrder
  resourceId: SortOrder
}

input MarketGroupWhereInput {
  AND: [MarketGroupWhereInput!]
  NOT: [MarketGroupWhereInput!]
  OR: [MarketGroupWhereInput!]
  address: StringNullableFilter
  baseTokenName: StringNullableFilter
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  collateralAsset: StringNullableFilter
  collateralDecimals: IntNullableFilter
  collateralSymbol: StringNullableFilter
  createdAt: DateTimeFilter
  deployTimestamp: IntNullableFilter
  deployTxnBlockNumber: IntNullableFilter
  events: EventListRelationFilter
  factoryAddress: StringNullableFilter
  id: IntFilter
  initializationNonce: StringNullableFilter
  isBridged: BoolFilter
  isCumulative: BoolFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  markets: MarketListRelationFilter
  minTradeSize: DecimalNullableFilter
  owner: StringNullableFilter
  question: StringNullableFilter
  quoteTokenName: StringNullableFilter
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
  rules: StringNullableFilter
}

input MarketGroupWhereUniqueInput {
  AND: [MarketGroupWhereInput!]
  NOT: [MarketGroupWhereInput!]
  OR: [MarketGroupWhereInput!]
  address: StringNullableFilter
  address_chainId: MarketGroupAddressChainIdCompoundUniqueInput
  baseTokenName: StringNullableFilter
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  collateralAsset: StringNullableFilter
  collateralDecimals: IntNullableFilter
  collateralSymbol: StringNullableFilter
  createdAt: DateTimeFilter
  deployTimestamp: IntNullableFilter
  deployTxnBlockNumber: IntNullableFilter
  events: EventListRelationFilter
  factoryAddress: StringNullableFilter
  id: Int
  initializationNonce: StringNullableFilter
  isBridged: BoolFilter
  isCumulative: BoolFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  markets: MarketListRelationFilter
  minTradeSize: DecimalNullableFilter
  owner: StringNullableFilter
  question: StringNullableFilter
  quoteTokenName: StringNullableFilter
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
  rules: StringNullableFilter
}

input MarketListRelationFilter {
  every: MarketWhereInput
  none: MarketWhereInput
  some: MarketWhereInput
}

input MarketMarketGroupIdMarketIdCompoundUniqueInput {
  marketGroupId: Int!
  marketId: Int!
}

type MarketMaxAggregate {
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  claimStatementNo: String
  claimStatementYesOrNumeric: String
  createdAt: DateTimeISO
  endTimestamp: Int
  id: Int
  marketGroupId: Int
  marketId: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  public: Boolean
  question: String
  settled: Boolean
  settledAt: Int
  settlementPriceD18: Decimal
  shortName: String
  startTimestamp: Int
  startingSqrtPriceX96: String
}

input MarketMaxOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  claimStatementNo: SortOrder
  claimStatementYesOrNumeric: SortOrder
  createdAt: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  optionName: SortOrder
  poolAddress: SortOrder
  public: SortOrder
  question: SortOrder
  settled: SortOrder
  settledAt: SortOrder
  settlementPriceD18: SortOrder
  shortName: SortOrder
  startTimestamp: SortOrder
  startingSqrtPriceX96: SortOrder
}

type MarketMinAggregate {
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  claimStatementNo: String
  claimStatementYesOrNumeric: String
  createdAt: DateTimeISO
  endTimestamp: Int
  id: Int
  marketGroupId: Int
  marketId: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsBondcurrency: String
  marketParamsFeerate: Int
  marketParamsOptimisticoraclev3: String
  marketParamsUniswappositionmanager: String
  marketParamsUniswapquoter: String
  marketParamsUniswapswaprouter: String
  maxPriceD18: Decimal
  minPriceD18: Decimal
  optionName: String
  poolAddress: String
  public: Boolean
  question: String
  settled: Boolean
  settledAt: Int
  settlementPriceD18: Decimal
  shortName: String
  startTimestamp: Int
  startingSqrtPriceX96: String
}

input MarketMinOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  claimStatementNo: SortOrder
  claimStatementYesOrNumeric: SortOrder
  createdAt: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsBondcurrency: SortOrder
  marketParamsFeerate: SortOrder
  marketParamsOptimisticoraclev3: SortOrder
  marketParamsUniswappositionmanager: SortOrder
  marketParamsUniswapquoter: SortOrder
  marketParamsUniswapswaprouter: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  optionName: SortOrder
  poolAddress: SortOrder
  public: SortOrder
  question: SortOrder
  settled: SortOrder
  settledAt: SortOrder
  settlementPriceD18: SortOrder
  shortName: SortOrder
  startTimestamp: SortOrder
  startingSqrtPriceX96: SortOrder
}

input MarketNullableRelationFilter {
  is: MarketWhereInput
  isNot: MarketWhereInput
}

input MarketOrderByRelationAggregateInput {
  _count: SortOrder
}

input MarketOrderByWithAggregationInput {
  _avg: MarketAvgOrderByAggregateInput
  _count: MarketCountOrderByAggregateInput
  _max: MarketMaxOrderByAggregateInput
  _min: MarketMinOrderByAggregateInput
  _sum: MarketSumOrderByAggregateInput
  baseAssetMaxPriceTick: SortOrderInput
  baseAssetMinPriceTick: SortOrderInput
  claimStatementNo: SortOrderInput
  claimStatementYesOrNumeric: SortOrderInput
  createdAt: SortOrder
  endTimestamp: SortOrderInput
  id: SortOrder
  marketGroupId: SortOrderInput
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  maxPriceD18: SortOrderInput
  minPriceD18: SortOrderInput
  optionName: SortOrderInput
  poolAddress: SortOrderInput
  public: SortOrder
  question: SortOrderInput
  settled: SortOrderInput
  settledAt: SortOrderInput
  settlementPriceD18: SortOrderInput
  shortName: SortOrderInput
  similarMarkets: SortOrder
  startTimestamp: SortOrderInput
  startingSqrtPriceX96: SortOrderInput
}

input MarketOrderByWithRelationInput {
  baseAssetMaxPriceTick: SortOrderInput
  baseAssetMinPriceTick: SortOrderInput
  claimStatementNo: SortOrderInput
  claimStatementYesOrNumeric: SortOrderInput
  createdAt: SortOrder
  endTimestamp: SortOrderInput
  id: SortOrder
  marketGroup: MarketGroupOrderByWithRelationInput
  marketGroupId: SortOrderInput
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrderInput
  marketParamsBondamount: SortOrderInput
  marketParamsBondcurrency: SortOrderInput
  marketParamsFeerate: SortOrderInput
  marketParamsOptimisticoraclev3: SortOrderInput
  marketParamsUniswappositionmanager: SortOrderInput
  marketParamsUniswapquoter: SortOrderInput
  marketParamsUniswapswaprouter: SortOrderInput
  maxPriceD18: SortOrderInput
  minPriceD18: SortOrderInput
  optionName: SortOrderInput
  poolAddress: SortOrderInput
  positions: PositionOrderByRelationAggregateInput
  public: SortOrder
  question: SortOrderInput
  settled: SortOrderInput
  settledAt: SortOrderInput
  settlementPriceD18: SortOrderInput
  shortName: SortOrderInput
  similarMarkets: SortOrder
  startTimestamp: SortOrderInput
  startingSqrtPriceX96: SortOrderInput
}

type MarketPrice {
  createdAt: DateTimeISO!
  id: Int!
  timestamp: BigInt!
  transaction(where: TransactionWhereInput): Transaction
  value: Decimal!
}

type MarketPriceAvgAggregate {
  id: Float
  timestamp: Float
  value: Decimal
}

input MarketPriceAvgOrderByAggregateInput {
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

type MarketPriceCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  timestamp: Int!
  value: Int!
}

input MarketPriceCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

type MarketPriceGroupBy {
  _avg: MarketPriceAvgAggregate
  _count: MarketPriceCountAggregate
  _max: MarketPriceMaxAggregate
  _min: MarketPriceMinAggregate
  _sum: MarketPriceSumAggregate
  createdAt: DateTimeISO!
  id: Int!
  timestamp: BigInt!
  value: Decimal!
}

type MarketPriceMaxAggregate {
  createdAt: DateTimeISO
  id: Int
  timestamp: BigInt
  value: Decimal
}

input MarketPriceMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

type MarketPriceMinAggregate {
  createdAt: DateTimeISO
  id: Int
  timestamp: BigInt
  value: Decimal
}

input MarketPriceMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

input MarketPriceNullableRelationFilter {
  is: MarketPriceWhereInput
  isNot: MarketPriceWhereInput
}

input MarketPriceOrderByWithAggregationInput {
  _avg: MarketPriceAvgOrderByAggregateInput
  _count: MarketPriceCountOrderByAggregateInput
  _max: MarketPriceMaxOrderByAggregateInput
  _min: MarketPriceMinOrderByAggregateInput
  _sum: MarketPriceSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

input MarketPriceOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  timestamp: SortOrder
  transaction: TransactionOrderByWithRelationInput
  value: SortOrder
}

enum MarketPriceScalarFieldEnum {
  createdAt
  id
  timestamp
  value
}

input MarketPriceScalarWhereWithAggregatesInput {
  AND: [MarketPriceScalarWhereWithAggregatesInput!]
  NOT: [MarketPriceScalarWhereWithAggregatesInput!]
  OR: [MarketPriceScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  timestamp: BigIntWithAggregatesFilter
  value: DecimalWithAggregatesFilter
}

type MarketPriceSumAggregate {
  id: Int
  timestamp: BigInt
  value: Decimal
}

input MarketPriceSumOrderByAggregateInput {
  id: SortOrder
  timestamp: SortOrder
  value: SortOrder
}

input MarketPriceWhereInput {
  AND: [MarketPriceWhereInput!]
  NOT: [MarketPriceWhereInput!]
  OR: [MarketPriceWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  value: DecimalFilter
}

input MarketPriceWhereUniqueInput {
  AND: [MarketPriceWhereInput!]
  NOT: [MarketPriceWhereInput!]
  OR: [MarketPriceWhereInput!]
  createdAt: DateTimeFilter
  id: Int
  timestamp: BigIntFilter
  transaction: TransactionNullableRelationFilter
  value: DecimalFilter
}

enum MarketScalarFieldEnum {
  baseAssetMaxPriceTick
  baseAssetMinPriceTick
  claimStatementNo
  claimStatementYesOrNumeric
  createdAt
  endTimestamp
  id
  marketGroupId
  marketId
  marketParamsAssertionliveness
  marketParamsBondamount
  marketParamsBondcurrency
  marketParamsFeerate
  marketParamsOptimisticoraclev3
  marketParamsUniswappositionmanager
  marketParamsUniswapquoter
  marketParamsUniswapswaprouter
  maxPriceD18
  minPriceD18
  optionName
  poolAddress
  public
  question
  settled
  settledAt
  settlementPriceD18
  shortName
  similarMarkets
  startTimestamp
  startingSqrtPriceX96
}

input MarketScalarWhereWithAggregatesInput {
  AND: [MarketScalarWhereWithAggregatesInput!]
  NOT: [MarketScalarWhereWithAggregatesInput!]
  OR: [MarketScalarWhereWithAggregatesInput!]
  baseAssetMaxPriceTick: IntNullableWithAggregatesFilter
  baseAssetMinPriceTick: IntNullableWithAggregatesFilter
  claimStatementNo: StringNullableWithAggregatesFilter
  claimStatementYesOrNumeric: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  endTimestamp: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  marketGroupId: IntNullableWithAggregatesFilter
  marketId: IntWithAggregatesFilter
  marketParamsAssertionliveness: DecimalNullableWithAggregatesFilter
  marketParamsBondamount: DecimalNullableWithAggregatesFilter
  marketParamsBondcurrency: StringNullableWithAggregatesFilter
  marketParamsFeerate: IntNullableWithAggregatesFilter
  marketParamsOptimisticoraclev3: StringNullableWithAggregatesFilter
  marketParamsUniswappositionmanager: StringNullableWithAggregatesFilter
  marketParamsUniswapquoter: StringNullableWithAggregatesFilter
  marketParamsUniswapswaprouter: StringNullableWithAggregatesFilter
  maxPriceD18: DecimalNullableWithAggregatesFilter
  minPriceD18: DecimalNullableWithAggregatesFilter
  optionName: StringNullableWithAggregatesFilter
  poolAddress: StringNullableWithAggregatesFilter
  public: BoolWithAggregatesFilter
  question: StringNullableWithAggregatesFilter
  settled: BoolNullableWithAggregatesFilter
  settledAt: IntNullableWithAggregatesFilter
  settlementPriceD18: DecimalNullableWithAggregatesFilter
  shortName: StringNullableWithAggregatesFilter
  similarMarkets: StringNullableListFilter
  startTimestamp: IntNullableWithAggregatesFilter
  startingSqrtPriceX96: StringNullableWithAggregatesFilter
}

type MarketSumAggregate {
  baseAssetMaxPriceTick: Int
  baseAssetMinPriceTick: Int
  endTimestamp: Int
  id: Int
  marketGroupId: Int
  marketId: Int
  marketParamsAssertionliveness: Decimal
  marketParamsBondamount: Decimal
  marketParamsFeerate: Int
  maxPriceD18: Decimal
  minPriceD18: Decimal
  settledAt: Int
  settlementPriceD18: Decimal
  startTimestamp: Int
}

input MarketSumOrderByAggregateInput {
  baseAssetMaxPriceTick: SortOrder
  baseAssetMinPriceTick: SortOrder
  endTimestamp: SortOrder
  id: SortOrder
  marketGroupId: SortOrder
  marketId: SortOrder
  marketParamsAssertionliveness: SortOrder
  marketParamsBondamount: SortOrder
  marketParamsFeerate: SortOrder
  maxPriceD18: SortOrder
  minPriceD18: SortOrder
  settledAt: SortOrder
  settlementPriceD18: SortOrder
  startTimestamp: SortOrder
}

input MarketWhereInput {
  AND: [MarketWhereInput!]
  NOT: [MarketWhereInput!]
  OR: [MarketWhereInput!]
  baseAssetMaxPriceTick: IntNullableFilter
  baseAssetMinPriceTick: IntNullableFilter
  claimStatementNo: StringNullableFilter
  claimStatementYesOrNumeric: StringNullableFilter
  createdAt: DateTimeFilter
  endTimestamp: IntNullableFilter
  id: IntFilter
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  marketId: IntFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  maxPriceD18: DecimalNullableFilter
  minPriceD18: DecimalNullableFilter
  optionName: StringNullableFilter
  poolAddress: StringNullableFilter
  positions: PositionListRelationFilter
  public: BoolFilter
  question: StringNullableFilter
  settled: BoolNullableFilter
  settledAt: IntNullableFilter
  settlementPriceD18: DecimalNullableFilter
  shortName: StringNullableFilter
  similarMarkets: StringNullableListFilter
  startTimestamp: IntNullableFilter
  startingSqrtPriceX96: StringNullableFilter
}

input MarketWhereUniqueInput {
  AND: [MarketWhereInput!]
  NOT: [MarketWhereInput!]
  OR: [MarketWhereInput!]
  baseAssetMaxPriceTick: IntNullableFilter
  baseAssetMinPriceTick: IntNullableFilter
  claimStatementNo: StringNullableFilter
  claimStatementYesOrNumeric: StringNullableFilter
  createdAt: DateTimeFilter
  endTimestamp: IntNullableFilter
  id: Int
  marketGroup: MarketGroupNullableRelationFilter
  marketGroupId: IntNullableFilter
  marketGroupId_marketId: MarketMarketGroupIdMarketIdCompoundUniqueInput
  marketId: IntFilter
  marketParamsAssertionliveness: DecimalNullableFilter
  marketParamsBondamount: DecimalNullableFilter
  marketParamsBondcurrency: StringNullableFilter
  marketParamsFeerate: IntNullableFilter
  marketParamsOptimisticoraclev3: StringNullableFilter
  marketParamsUniswappositionmanager: StringNullableFilter
  marketParamsUniswapquoter: StringNullableFilter
  marketParamsUniswapswaprouter: StringNullableFilter
  maxPriceD18: DecimalNullableFilter
  minPriceD18: DecimalNullableFilter
  optionName: StringNullableFilter
  poolAddress: StringNullableFilter
  positions: PositionListRelationFilter
  public: BoolFilter
  question: StringNullableFilter
  settled: BoolNullableFilter
  settledAt: IntNullableFilter
  settlementPriceD18: DecimalNullableFilter
  shortName: StringNullableFilter
  similarMarkets: StringNullableListFilter
  startTimestamp: IntNullableFilter
  startingSqrtPriceX96: StringNullableFilter
}

input NestedBigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input NestedBigIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedBigIntFilter
  _min: NestedBigIntFilter
  _sum: NestedBigIntFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntWithAggregatesFilter
  notIn: [BigInt!]
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedBoolNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedBoolNullableFilter
  _min: NestedBoolNullableFilter
  equals: Boolean
  not: NestedBoolNullableWithAggregatesFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedDecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableFilter
  notIn: [Decimal!]
}

input NestedDecimalNullableWithAggregatesFilter {
  _avg: NestedDecimalNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedDecimalNullableFilter
  _min: NestedDecimalNullableFilter
  _sum: NestedDecimalNullableFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalNullableWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedDecimalWithAggregatesFilter {
  _avg: NestedDecimalFilter
  _count: NestedIntFilter
  _max: NestedDecimalFilter
  _min: NestedDecimalFilter
  _sum: NestedDecimalFilter
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal!]
  lt: Decimal
  lte: Decimal
  not: NestedDecimalWithAggregatesFilter
  notIn: [Decimal!]
}

input NestedEnumtransaction_type_enumFilter {
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumFilter
  notIn: [transaction_type_enum!]
}

input NestedEnumtransaction_type_enumWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumtransaction_type_enumFilter
  _min: NestedEnumtransaction_type_enumFilter
  equals: transaction_type_enum
  in: [transaction_type_enum!]
  not: NestedEnumtransaction_type_enumWithAggregatesFilter
  notIn: [transaction_type_enum!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type ParlayType {
  chainId: Int!
  endsAt: Int
  id: Int!
  maker: String!
  makerCollateral: String
  makerNftTokenId: String!
  makerWon: Boolean
  marketAddress: String!
  mintedAt: Int!
  predictedOutcomes: [PredictedOutcomeType!]!
  refCode: String
  settledAt: Int
  status: String!
  taker: String!
  takerCollateral: String
  takerNftTokenId: String!
  totalCollateral: String!
}

type PnLType {
  collateralAddress: String
  collateralDecimals: Int
  collateralSymbol: String
  marketId: Int!
  openPositionsPnL: String!
  owner: String!
  positionCount: Int!
  positions: [Int!]!
  totalDeposits: String!
  totalPnL: String!
  totalWithdrawals: String!
}

type Position {
  _count: PositionCount
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String!
  createdAt: DateTimeISO!
  highPriceTick: Decimal
  id: Int!
  isLP: Boolean!
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: String
  lpQuoteToken: String
  market(where: MarketWhereInput): Market
  marketId: Int
  owner: String
  positionId: Int!
  quoteToken: String
  transactions(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): [Transaction!]!
}

type PositionAvgAggregate {
  highPriceTick: Decimal
  id: Float
  lowPriceTick: Decimal
  marketId: Float
  positionId: Float
}

input PositionAvgOrderByAggregateInput {
  highPriceTick: SortOrder
  id: SortOrder
  lowPriceTick: SortOrder
  marketId: SortOrder
  positionId: SortOrder
}

type PositionCount {
  transaction(where: TransactionWhereInput): Int!
}

type PositionCountAggregate {
  _all: Int!
  baseToken: Int!
  borrowedBaseToken: Int!
  borrowedQuoteToken: Int!
  collateral: Int!
  createdAt: Int!
  highPriceTick: Int!
  id: Int!
  isLP: Int!
  isSettled: Int!
  lowPriceTick: Int!
  lpBaseToken: Int!
  lpQuoteToken: Int!
  marketId: Int!
  owner: Int!
  positionId: Int!
  quoteToken: Int!
}

input PositionCountOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  owner: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

type PositionGroupBy {
  _avg: PositionAvgAggregate
  _count: PositionCountAggregate
  _max: PositionMaxAggregate
  _min: PositionMinAggregate
  _sum: PositionSumAggregate
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String!
  createdAt: DateTimeISO!
  highPriceTick: Decimal
  id: Int!
  isLP: Boolean!
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: String
  lpQuoteToken: String
  marketId: Int
  owner: String
  positionId: Int!
  quoteToken: String
}

input PositionListRelationFilter {
  every: PositionWhereInput
  none: PositionWhereInput
  some: PositionWhereInput
}

type PositionMaxAggregate {
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String
  createdAt: DateTimeISO
  highPriceTick: Decimal
  id: Int
  isLP: Boolean
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: String
  lpQuoteToken: String
  marketId: Int
  owner: String
  positionId: Int
  quoteToken: String
}

input PositionMaxOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  owner: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

type PositionMinAggregate {
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String
  createdAt: DateTimeISO
  highPriceTick: Decimal
  id: Int
  isLP: Boolean
  isSettled: Boolean
  lowPriceTick: Decimal
  lpBaseToken: String
  lpQuoteToken: String
  marketId: Int
  owner: String
  positionId: Int
  quoteToken: String
}

input PositionMinOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrder
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrder
  lowPriceTick: SortOrder
  lpBaseToken: SortOrder
  lpQuoteToken: SortOrder
  marketId: SortOrder
  owner: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
}

input PositionNullableRelationFilter {
  is: PositionWhereInput
  isNot: PositionWhereInput
}

input PositionOrderByRelationAggregateInput {
  _count: SortOrder
}

input PositionOrderByWithAggregationInput {
  _avg: PositionAvgOrderByAggregateInput
  _count: PositionCountOrderByAggregateInput
  _max: PositionMaxOrderByAggregateInput
  _min: PositionMinOrderByAggregateInput
  _sum: PositionSumOrderByAggregateInput
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrderInput
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrderInput
  lowPriceTick: SortOrderInput
  lpBaseToken: SortOrderInput
  lpQuoteToken: SortOrderInput
  marketId: SortOrderInput
  owner: SortOrderInput
  positionId: SortOrder
  quoteToken: SortOrderInput
}

input PositionOrderByWithRelationInput {
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  createdAt: SortOrder
  highPriceTick: SortOrderInput
  id: SortOrder
  isLP: SortOrder
  isSettled: SortOrderInput
  lowPriceTick: SortOrderInput
  lpBaseToken: SortOrderInput
  lpQuoteToken: SortOrderInput
  market: MarketOrderByWithRelationInput
  marketId: SortOrderInput
  owner: SortOrderInput
  positionId: SortOrder
  quoteToken: SortOrderInput
  transactions: TransactionOrderByRelationAggregateInput
}

input PositionPositionIdMarketIdCompoundUniqueInput {
  marketId: Int!
  positionId: Int!
}

enum PositionScalarFieldEnum {
  baseToken
  borrowedBaseToken
  borrowedQuoteToken
  collateral
  createdAt
  highPriceTick
  id
  isLP
  isSettled
  lowPriceTick
  lpBaseToken
  lpQuoteToken
  marketId
  owner
  positionId
  quoteToken
}

input PositionScalarWhereWithAggregatesInput {
  AND: [PositionScalarWhereWithAggregatesInput!]
  NOT: [PositionScalarWhereWithAggregatesInput!]
  OR: [PositionScalarWhereWithAggregatesInput!]
  baseToken: StringNullableWithAggregatesFilter
  borrowedBaseToken: StringNullableWithAggregatesFilter
  borrowedQuoteToken: StringNullableWithAggregatesFilter
  collateral: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  highPriceTick: DecimalNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  isLP: BoolWithAggregatesFilter
  isSettled: BoolNullableWithAggregatesFilter
  lowPriceTick: DecimalNullableWithAggregatesFilter
  lpBaseToken: StringNullableWithAggregatesFilter
  lpQuoteToken: StringNullableWithAggregatesFilter
  marketId: IntNullableWithAggregatesFilter
  owner: StringNullableWithAggregatesFilter
  positionId: IntWithAggregatesFilter
  quoteToken: StringNullableWithAggregatesFilter
}

type PositionSumAggregate {
  highPriceTick: Decimal
  id: Int
  lowPriceTick: Decimal
  marketId: Int
  positionId: Int
}

input PositionSumOrderByAggregateInput {
  highPriceTick: SortOrder
  id: SortOrder
  lowPriceTick: SortOrder
  marketId: SortOrder
  positionId: SortOrder
}

input PositionWhereInput {
  AND: [PositionWhereInput!]
  NOT: [PositionWhereInput!]
  OR: [PositionWhereInput!]
  baseToken: StringNullableFilter
  borrowedBaseToken: StringNullableFilter
  borrowedQuoteToken: StringNullableFilter
  collateral: StringFilter
  createdAt: DateTimeFilter
  highPriceTick: DecimalNullableFilter
  id: IntFilter
  isLP: BoolFilter
  isSettled: BoolNullableFilter
  lowPriceTick: DecimalNullableFilter
  lpBaseToken: StringNullableFilter
  lpQuoteToken: StringNullableFilter
  market: MarketNullableRelationFilter
  marketId: IntNullableFilter
  owner: StringNullableFilter
  positionId: IntFilter
  quoteToken: StringNullableFilter
  transactions: TransactionListRelationFilter
}

input PositionWhereUniqueInput {
  AND: [PositionWhereInput!]
  NOT: [PositionWhereInput!]
  OR: [PositionWhereInput!]
  baseToken: StringNullableFilter
  borrowedBaseToken: StringNullableFilter
  borrowedQuoteToken: StringNullableFilter
  collateral: StringFilter
  createdAt: DateTimeFilter
  highPriceTick: DecimalNullableFilter
  id: Int
  isLP: BoolFilter
  isSettled: BoolNullableFilter
  lowPriceTick: DecimalNullableFilter
  lpBaseToken: StringNullableFilter
  lpQuoteToken: StringNullableFilter
  market: MarketNullableRelationFilter
  marketId: IntNullableFilter
  owner: StringNullableFilter
  positionId: IntFilter
  positionId_marketId: PositionPositionIdMarketIdCompoundUniqueInput
  quoteToken: StringNullableFilter
  transactions: TransactionListRelationFilter
}

type PredictedOutcomeType {
  condition: ConditionSummary
  conditionId: String!
  prediction: Boolean!
}

type ProfitRankType {
  owner: String!
  rank: Int
  totalParticipants: Int!
  totalPnL: Float!
}

type Query {
  accuracyRankByAddress(attester: String!): AccuracyRankType!
  aggregateAttestation(cursor: AttestationWhereUniqueInput, orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): AggregateAttestation!
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateCondition(cursor: ConditionWhereUniqueInput, orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): AggregateCondition!
  aggregateMarket(cursor: MarketWhereUniqueInput, orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): AggregateMarket!
  aggregateMarketGroup(cursor: MarketGroupWhereUniqueInput, orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): AggregateMarketGroup!
  aggregateMarketPrice(cursor: MarketPriceWhereUniqueInput, orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): AggregateMarketPrice!
  aggregatePosition(cursor: PositionWhereUniqueInput, orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): AggregatePosition!
  aggregateResource(cursor: ResourceWhereUniqueInput, orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): AggregateResource!
  aggregateResourcePrice(cursor: ResourcePriceWhereUniqueInput, orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): AggregateResourcePrice!
  aggregateTransaction(cursor: TransactionWhereUniqueInput, orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): AggregateTransaction!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  allTimeProfitLeaderboard: [AggregatedProfitEntryType!]!
  attestation(where: AttestationWhereUniqueInput!): Attestation
  attestations(cursor: AttestationWhereUniqueInput, distinct: [AttestationScalarFieldEnum!], orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): [Attestation!]!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  condition(where: ConditionWhereUniqueInput!): Condition
  conditions(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): [Condition!]!
  findFirstAttestation(cursor: AttestationWhereUniqueInput, distinct: [AttestationScalarFieldEnum!], orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): Attestation
  findFirstAttestationOrThrow(cursor: AttestationWhereUniqueInput, distinct: [AttestationScalarFieldEnum!], orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): Attestation
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCategoryOrThrow(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCondition(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): Condition
  findFirstConditionOrThrow(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): Condition
  findFirstMarket(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): Market
  findFirstMarketGroup(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): MarketGroup
  findFirstMarketGroupOrThrow(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): MarketGroup
  findFirstMarketOrThrow(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): Market
  findFirstMarketPrice(cursor: MarketPriceWhereUniqueInput, distinct: [MarketPriceScalarFieldEnum!], orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): MarketPrice
  findFirstMarketPriceOrThrow(cursor: MarketPriceWhereUniqueInput, distinct: [MarketPriceScalarFieldEnum!], orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): MarketPrice
  findFirstPosition(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): Position
  findFirstPositionOrThrow(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): Position
  findFirstResource(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): Resource
  findFirstResourceOrThrow(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): Resource
  findFirstResourcePrice(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): ResourcePrice
  findFirstResourcePriceOrThrow(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): ResourcePrice
  findFirstTransaction(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): Transaction
  findFirstTransactionOrThrow(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): Transaction
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  forecasterScore(attester: String!): ForecasterScoreType
  getAttestation(where: AttestationWhereUniqueInput!): Attestation
  getCategory(where: CategoryWhereUniqueInput!): Category
  getCondition(where: ConditionWhereUniqueInput!): Condition
  getMarket(where: MarketWhereUniqueInput!): Market
  getMarketGroup(where: MarketGroupWhereUniqueInput!): MarketGroup
  getMarketLeaderboard(address: String!, chainId: Int!, marketId: String!): [PnLType!]!
  getMarketPrice(where: MarketPriceWhereUniqueInput!): MarketPrice
  getParlayLeaderboard(chainId: Int!, marketAddress: String!): [PnLType!]!
  getPosition(where: PositionWhereUniqueInput!): Position
  getResource(where: ResourceWhereUniqueInput!): Resource
  getResourcePrice(where: ResourcePriceWhereUniqueInput!): ResourcePrice
  getTransaction(where: TransactionWhereUniqueInput!): Transaction
  getUser(where: UserWhereUniqueInput!): User
  groupByAttestation(by: [AttestationScalarFieldEnum!]!, having: AttestationScalarWhereWithAggregatesInput, orderBy: [AttestationOrderByWithAggregationInput!], skip: Int, take: Int, where: AttestationWhereInput): [AttestationGroupBy!]!
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByCondition(by: [ConditionScalarFieldEnum!]!, having: ConditionScalarWhereWithAggregatesInput, orderBy: [ConditionOrderByWithAggregationInput!], skip: Int, take: Int, where: ConditionWhereInput): [ConditionGroupBy!]!
  groupByMarket(by: [MarketScalarFieldEnum!]!, having: MarketScalarWhereWithAggregatesInput, orderBy: [MarketOrderByWithAggregationInput!], skip: Int, take: Int, where: MarketWhereInput): [MarketGroupBy!]!
  groupByMarketGroup(by: [MarketGroupScalarFieldEnum!]!, having: MarketGroupScalarWhereWithAggregatesInput, orderBy: [MarketGroupOrderByWithAggregationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroupGroupBy!]!
  groupByMarketPrice(by: [MarketPriceScalarFieldEnum!]!, having: MarketPriceScalarWhereWithAggregatesInput, orderBy: [MarketPriceOrderByWithAggregationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): [MarketPriceGroupBy!]!
  groupByPosition(by: [PositionScalarFieldEnum!]!, having: PositionScalarWhereWithAggregatesInput, orderBy: [PositionOrderByWithAggregationInput!], skip: Int, take: Int, where: PositionWhereInput): [PositionGroupBy!]!
  groupByResource(by: [ResourceScalarFieldEnum!]!, having: ResourceScalarWhereWithAggregatesInput, orderBy: [ResourceOrderByWithAggregationInput!], skip: Int, take: Int, where: ResourceWhereInput): [ResourceGroupBy!]!
  groupByResourcePrice(by: [ResourcePriceScalarFieldEnum!]!, having: ResourcePriceScalarWhereWithAggregatesInput, orderBy: [ResourcePriceOrderByWithAggregationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): [ResourcePriceGroupBy!]!
  groupByTransaction(by: [TransactionScalarFieldEnum!]!, having: TransactionScalarWhereWithAggregatesInput, orderBy: [TransactionOrderByWithAggregationInput!], skip: Int, take: Int, where: TransactionWhereInput): [TransactionGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  indexCandles(address: String!, chainId: Int!, from: Int!, interval: Int!, marketId: String!, to: Int!): CandleAndTimestampType!
  indexPriceAtTime(address: String!, chainId: Int!, marketId: String!, timestamp: Int!): CandleType
  legacyMarketCandles(address: String!, chainId: Int!, from: Int!, interval: Int!, marketId: String!, to: Int!): [CandleType!]!
  market(where: MarketWhereUniqueInput!): Market
  marketCandles(address: String!, chainId: Int!, from: Int!, interval: Int!, marketId: String!, to: Int!): CandleAndTimestampType!
  marketGroup(where: MarketGroupWhereUniqueInput!): MarketGroup
  marketGroups(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroup!]!
  marketPrice(where: MarketPriceWhereUniqueInput!): MarketPrice
  marketPrices(cursor: MarketPriceWhereUniqueInput, distinct: [MarketPriceScalarFieldEnum!], orderBy: [MarketPriceOrderByWithRelationInput!], skip: Int, take: Int, where: MarketPriceWhereInput): [MarketPrice!]!
  markets(cursor: MarketWhereUniqueInput, distinct: [MarketScalarFieldEnum!], orderBy: [MarketOrderByWithRelationInput!], skip: Int, take: Int, where: MarketWhereInput): [Market!]!
  position(where: PositionWhereUniqueInput!): Position
  positions(cursor: PositionWhereUniqueInput, distinct: [PositionScalarFieldEnum!], orderBy: [PositionOrderByWithRelationInput!], skip: Int, take: Int, where: PositionWhereInput): [Position!]!
  profitRankByAddress(owner: String!): ProfitRankType!
  resource(where: ResourceWhereUniqueInput!): Resource
  resourceCandles(from: Int!, interval: Int!, slug: String!, to: Int!): CandleAndTimestampType!
  resourcePrice(where: ResourcePriceWhereUniqueInput!): ResourcePrice
  resourcePrices(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): [ResourcePrice!]!
  resourceTrailingAverageCandles(from: Int!, interval: Int!, slug: String!, to: Int!, trailingAvgTime: Int!): CandleAndTimestampType!
  resources(cursor: ResourceWhereUniqueInput, distinct: [ResourceScalarFieldEnum!], orderBy: [ResourceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourceWhereInput): [Resource!]!
  topForecasters(limit: Int! = 10): [ForecasterScoreType!]!
  totalVolumeByMarket(chainId: Int!, marketAddress: String!, marketId: Int!): Float!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(cursor: TransactionWhereUniqueInput, distinct: [TransactionScalarFieldEnum!], orderBy: [TransactionOrderByWithRelationInput!], skip: Int, take: Int, where: TransactionWhereInput): [Transaction!]!
  user(where: UserWhereUniqueInput!): User
  userParlays(address: String!, chainId: Int, orderBy: String, orderDirection: String, skip: Int! = 0, take: Int! = 50): [ParlayType!]!
  userParlaysCount(address: String!, chainId: Int): Int!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type Resource {
  _count: ResourceCount
  category(where: CategoryWhereInput): Category
  categoryId: Int
  createdAt: DateTimeISO!
  id: Int!
  marketGroups(cursor: MarketGroupWhereUniqueInput, distinct: [MarketGroupScalarFieldEnum!], orderBy: [MarketGroupOrderByWithRelationInput!], skip: Int, take: Int, where: MarketGroupWhereInput): [MarketGroup!]!
  name: String!
  resourcePrices(cursor: ResourcePriceWhereUniqueInput, distinct: [ResourcePriceScalarFieldEnum!], orderBy: [ResourcePriceOrderByWithRelationInput!], skip: Int, take: Int, where: ResourcePriceWhereInput): [ResourcePrice!]!
  slug: String!
}

type ResourceAvgAggregate {
  categoryId: Float
  id: Float
}

input ResourceAvgOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

type ResourceCount {
  market_group(where: MarketGroupWhereInput): Int!
  resource_price(where: ResourcePriceWhereInput): Int!
}

type ResourceCountAggregate {
  _all: Int!
  categoryId: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  slug: Int!
}

input ResourceCountOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type ResourceGroupBy {
  _avg: ResourceAvgAggregate
  _count: ResourceCountAggregate
  _max: ResourceMaxAggregate
  _min: ResourceMinAggregate
  _sum: ResourceSumAggregate
  categoryId: Int
  createdAt: DateTimeISO!
  id: Int!
  name: String!
  slug: String!
}

input ResourceListRelationFilter {
  every: ResourceWhereInput
  none: ResourceWhereInput
  some: ResourceWhereInput
}

type ResourceMaxAggregate {
  categoryId: Int
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input ResourceMaxOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type ResourceMinAggregate {
  categoryId: Int
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input ResourceMinOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input ResourceNullableRelationFilter {
  is: ResourceWhereInput
  isNot: ResourceWhereInput
}

input ResourceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResourceOrderByWithAggregationInput {
  _avg: ResourceAvgOrderByAggregateInput
  _count: ResourceCountOrderByAggregateInput
  _max: ResourceMaxOrderByAggregateInput
  _min: ResourceMinOrderByAggregateInput
  _sum: ResourceSumOrderByAggregateInput
  categoryId: SortOrderInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input ResourceOrderByWithRelationInput {
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrderInput
  createdAt: SortOrder
  id: SortOrder
  marketGroups: MarketGroupOrderByRelationAggregateInput
  name: SortOrder
  resourcePrices: ResourcePriceOrderByRelationAggregateInput
  slug: SortOrder
}

type ResourcePrice {
  blockNumber: Int!
  createdAt: DateTimeISO!
  feePaid: String!
  id: Int!
  resource(where: ResourceWhereInput): Resource
  resourceId: Int
  timestamp: Int!
  used: String!
  value: String!
}

type ResourcePriceAvgAggregate {
  blockNumber: Float
  id: Float
  resourceId: Float
  timestamp: Float
}

input ResourcePriceAvgOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
}

type ResourcePriceCountAggregate {
  _all: Int!
  blockNumber: Int!
  createdAt: Int!
  feePaid: Int!
  id: Int!
  resourceId: Int!
  timestamp: Int!
  used: Int!
  value: Int!
}

input ResourcePriceCountOrderByAggregateInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

type ResourcePriceGroupBy {
  _avg: ResourcePriceAvgAggregate
  _count: ResourcePriceCountAggregate
  _max: ResourcePriceMaxAggregate
  _min: ResourcePriceMinAggregate
  _sum: ResourcePriceSumAggregate
  blockNumber: Int!
  createdAt: DateTimeISO!
  feePaid: String!
  id: Int!
  resourceId: Int
  timestamp: Int!
  used: String!
  value: String!
}

input ResourcePriceListRelationFilter {
  every: ResourcePriceWhereInput
  none: ResourcePriceWhereInput
  some: ResourcePriceWhereInput
}

type ResourcePriceMaxAggregate {
  blockNumber: Int
  createdAt: DateTimeISO
  feePaid: String
  id: Int
  resourceId: Int
  timestamp: Int
  used: String
  value: String
}

input ResourcePriceMaxOrderByAggregateInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

type ResourcePriceMinAggregate {
  blockNumber: Int
  createdAt: DateTimeISO
  feePaid: String
  id: Int
  resourceId: Int
  timestamp: Int
  used: String
  value: String
}

input ResourcePriceMinOrderByAggregateInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

input ResourcePriceOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResourcePriceOrderByWithAggregationInput {
  _avg: ResourcePriceAvgOrderByAggregateInput
  _count: ResourcePriceCountOrderByAggregateInput
  _max: ResourcePriceMaxOrderByAggregateInput
  _min: ResourcePriceMinOrderByAggregateInput
  _sum: ResourcePriceSumOrderByAggregateInput
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resourceId: SortOrderInput
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

input ResourcePriceOrderByWithRelationInput {
  blockNumber: SortOrder
  createdAt: SortOrder
  feePaid: SortOrder
  id: SortOrder
  resource: ResourceOrderByWithRelationInput
  resourceId: SortOrderInput
  timestamp: SortOrder
  used: SortOrder
  value: SortOrder
}

input ResourcePriceResourceIdTimestampCompoundUniqueInput {
  resourceId: Int!
  timestamp: Int!
}

enum ResourcePriceScalarFieldEnum {
  blockNumber
  createdAt
  feePaid
  id
  resourceId
  timestamp
  used
  value
}

input ResourcePriceScalarWhereWithAggregatesInput {
  AND: [ResourcePriceScalarWhereWithAggregatesInput!]
  NOT: [ResourcePriceScalarWhereWithAggregatesInput!]
  OR: [ResourcePriceScalarWhereWithAggregatesInput!]
  blockNumber: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  feePaid: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  resourceId: IntNullableWithAggregatesFilter
  timestamp: IntWithAggregatesFilter
  used: StringWithAggregatesFilter
  value: StringWithAggregatesFilter
}

type ResourcePriceSumAggregate {
  blockNumber: Int
  id: Int
  resourceId: Int
  timestamp: Int
}

input ResourcePriceSumOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  resourceId: SortOrder
  timestamp: SortOrder
}

input ResourcePriceWhereInput {
  AND: [ResourcePriceWhereInput!]
  NOT: [ResourcePriceWhereInput!]
  OR: [ResourcePriceWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  feePaid: StringFilter
  id: IntFilter
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
  timestamp: IntFilter
  used: StringFilter
  value: StringFilter
}

input ResourcePriceWhereUniqueInput {
  AND: [ResourcePriceWhereInput!]
  NOT: [ResourcePriceWhereInput!]
  OR: [ResourcePriceWhereInput!]
  blockNumber: IntFilter
  createdAt: DateTimeFilter
  feePaid: StringFilter
  id: Int
  resource: ResourceNullableRelationFilter
  resourceId: IntNullableFilter
  resourceId_timestamp: ResourcePriceResourceIdTimestampCompoundUniqueInput
  timestamp: IntFilter
  used: StringFilter
  value: StringFilter
}

enum ResourceScalarFieldEnum {
  categoryId
  createdAt
  id
  name
  slug
}

input ResourceScalarWhereWithAggregatesInput {
  AND: [ResourceScalarWhereWithAggregatesInput!]
  NOT: [ResourceScalarWhereWithAggregatesInput!]
  OR: [ResourceScalarWhereWithAggregatesInput!]
  categoryId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

type ResourceSumAggregate {
  categoryId: Int
  id: Int
}

input ResourceSumOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

input ResourceWhereInput {
  AND: [ResourceWhereInput!]
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  marketGroups: MarketGroupListRelationFilter
  name: StringFilter
  resourcePrices: ResourcePriceListRelationFilter
  slug: StringFilter
}

input ResourceWhereUniqueInput {
  AND: [ResourceWhereInput!]
  NOT: [ResourceWhereInput!]
  OR: [ResourceWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  createdAt: DateTimeFilter
  id: Int
  marketGroups: MarketGroupListRelationFilter
  name: String
  resourcePrices: ResourcePriceListRelationFilter
  slug: String
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Transaction {
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String!
  collateralTransfer(where: CollateralTransferWhereInput): CollateralTransfer
  collateralTransferId: Int
  createdAt: DateTimeISO!
  event(where: EventWhereInput): Event
  eventId: Int
  id: Int!
  lpBaseDeltaToken: String
  lpQuoteDeltaToken: String
  marketPrice(where: MarketPriceWhereInput): MarketPrice
  marketPriceId: Int
  position(where: PositionWhereInput): Position
  positionId: Int
  quoteToken: String
  tradeRatioD18: String
  type: transaction_type_enum!
}

type TransactionAvgAggregate {
  collateralTransferId: Float
  eventId: Float
  id: Float
  marketPriceId: Float
  positionId: Float
}

input TransactionAvgOrderByAggregateInput {
  collateralTransferId: SortOrder
  eventId: SortOrder
  id: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
}

type TransactionCountAggregate {
  _all: Int!
  baseToken: Int!
  borrowedBaseToken: Int!
  borrowedQuoteToken: Int!
  collateral: Int!
  collateralTransferId: Int!
  createdAt: Int!
  eventId: Int!
  id: Int!
  lpBaseDeltaToken: Int!
  lpQuoteDeltaToken: Int!
  marketPriceId: Int!
  positionId: Int!
  quoteToken: Int!
  tradeRatioD18: Int!
  type: Int!
}

input TransactionCountOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  createdAt: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
  type: SortOrder
}

type TransactionGroupBy {
  _avg: TransactionAvgAggregate
  _count: TransactionCountAggregate
  _max: TransactionMaxAggregate
  _min: TransactionMinAggregate
  _sum: TransactionSumAggregate
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String!
  collateralTransferId: Int
  createdAt: DateTimeISO!
  eventId: Int
  id: Int!
  lpBaseDeltaToken: String
  lpQuoteDeltaToken: String
  marketPriceId: Int
  positionId: Int
  quoteToken: String
  tradeRatioD18: String
  type: transaction_type_enum!
}

input TransactionListRelationFilter {
  every: TransactionWhereInput
  none: TransactionWhereInput
  some: TransactionWhereInput
}

type TransactionMaxAggregate {
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String
  collateralTransferId: Int
  createdAt: DateTimeISO
  eventId: Int
  id: Int
  lpBaseDeltaToken: String
  lpQuoteDeltaToken: String
  marketPriceId: Int
  positionId: Int
  quoteToken: String
  tradeRatioD18: String
  type: transaction_type_enum
}

input TransactionMaxOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  createdAt: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
  type: SortOrder
}

type TransactionMinAggregate {
  baseToken: String
  borrowedBaseToken: String
  borrowedQuoteToken: String
  collateral: String
  collateralTransferId: Int
  createdAt: DateTimeISO
  eventId: Int
  id: Int
  lpBaseDeltaToken: String
  lpQuoteDeltaToken: String
  marketPriceId: Int
  positionId: Int
  quoteToken: String
  tradeRatioD18: String
  type: transaction_type_enum
}

input TransactionMinOrderByAggregateInput {
  baseToken: SortOrder
  borrowedBaseToken: SortOrder
  borrowedQuoteToken: SortOrder
  collateral: SortOrder
  collateralTransferId: SortOrder
  createdAt: SortOrder
  eventId: SortOrder
  id: SortOrder
  lpBaseDeltaToken: SortOrder
  lpQuoteDeltaToken: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
  quoteToken: SortOrder
  tradeRatioD18: SortOrder
  type: SortOrder
}

input TransactionNullableRelationFilter {
  is: TransactionWhereInput
  isNot: TransactionWhereInput
}

input TransactionOrderByRelationAggregateInput {
  _count: SortOrder
}

input TransactionOrderByWithAggregationInput {
  _avg: TransactionAvgOrderByAggregateInput
  _count: TransactionCountOrderByAggregateInput
  _max: TransactionMaxOrderByAggregateInput
  _min: TransactionMinOrderByAggregateInput
  _sum: TransactionSumOrderByAggregateInput
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  collateralTransferId: SortOrderInput
  createdAt: SortOrder
  eventId: SortOrderInput
  id: SortOrder
  lpBaseDeltaToken: SortOrderInput
  lpQuoteDeltaToken: SortOrderInput
  marketPriceId: SortOrderInput
  positionId: SortOrderInput
  quoteToken: SortOrderInput
  tradeRatioD18: SortOrderInput
  type: SortOrder
}

input TransactionOrderByWithRelationInput {
  baseToken: SortOrderInput
  borrowedBaseToken: SortOrderInput
  borrowedQuoteToken: SortOrderInput
  collateral: SortOrder
  collateralTransfer: CollateralTransferOrderByWithRelationInput
  collateralTransferId: SortOrderInput
  createdAt: SortOrder
  event: EventOrderByWithRelationInput
  eventId: SortOrderInput
  id: SortOrder
  lpBaseDeltaToken: SortOrderInput
  lpQuoteDeltaToken: SortOrderInput
  marketPrice: MarketPriceOrderByWithRelationInput
  marketPriceId: SortOrderInput
  position: PositionOrderByWithRelationInput
  positionId: SortOrderInput
  quoteToken: SortOrderInput
  tradeRatioD18: SortOrderInput
  type: SortOrder
}

enum TransactionScalarFieldEnum {
  baseToken
  borrowedBaseToken
  borrowedQuoteToken
  collateral
  collateralTransferId
  createdAt
  eventId
  id
  lpBaseDeltaToken
  lpQuoteDeltaToken
  marketPriceId
  positionId
  quoteToken
  tradeRatioD18
  type
}

input TransactionScalarWhereWithAggregatesInput {
  AND: [TransactionScalarWhereWithAggregatesInput!]
  NOT: [TransactionScalarWhereWithAggregatesInput!]
  OR: [TransactionScalarWhereWithAggregatesInput!]
  baseToken: StringNullableWithAggregatesFilter
  borrowedBaseToken: StringNullableWithAggregatesFilter
  borrowedQuoteToken: StringNullableWithAggregatesFilter
  collateral: StringWithAggregatesFilter
  collateralTransferId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  eventId: IntNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  lpBaseDeltaToken: StringNullableWithAggregatesFilter
  lpQuoteDeltaToken: StringNullableWithAggregatesFilter
  marketPriceId: IntNullableWithAggregatesFilter
  positionId: IntNullableWithAggregatesFilter
  quoteToken: StringNullableWithAggregatesFilter
  tradeRatioD18: StringNullableWithAggregatesFilter
  type: Enumtransaction_type_enumWithAggregatesFilter
}

type TransactionSumAggregate {
  collateralTransferId: Int
  eventId: Int
  id: Int
  marketPriceId: Int
  positionId: Int
}

input TransactionSumOrderByAggregateInput {
  collateralTransferId: SortOrder
  eventId: SortOrder
  id: SortOrder
  marketPriceId: SortOrder
  positionId: SortOrder
}

input TransactionWhereInput {
  AND: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  baseToken: StringNullableFilter
  borrowedBaseToken: StringNullableFilter
  borrowedQuoteToken: StringNullableFilter
  collateral: StringFilter
  collateralTransfer: CollateralTransferNullableRelationFilter
  collateralTransferId: IntNullableFilter
  createdAt: DateTimeFilter
  event: EventNullableRelationFilter
  eventId: IntNullableFilter
  id: IntFilter
  lpBaseDeltaToken: StringNullableFilter
  lpQuoteDeltaToken: StringNullableFilter
  marketPrice: MarketPriceNullableRelationFilter
  marketPriceId: IntNullableFilter
  position: PositionNullableRelationFilter
  positionId: IntNullableFilter
  quoteToken: StringNullableFilter
  tradeRatioD18: StringNullableFilter
  type: Enumtransaction_type_enumFilter
}

input TransactionWhereUniqueInput {
  AND: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  baseToken: StringNullableFilter
  borrowedBaseToken: StringNullableFilter
  borrowedQuoteToken: StringNullableFilter
  collateral: StringFilter
  collateralTransfer: CollateralTransferNullableRelationFilter
  collateralTransferId: Int
  createdAt: DateTimeFilter
  event: EventNullableRelationFilter
  eventId: Int
  id: Int
  lpBaseDeltaToken: StringNullableFilter
  lpQuoteDeltaToken: StringNullableFilter
  marketPrice: MarketPriceNullableRelationFilter
  marketPriceId: Int
  position: PositionNullableRelationFilter
  positionId: IntNullableFilter
  quoteToken: StringNullableFilter
  tradeRatioD18: StringNullableFilter
  type: Enumtransaction_type_enumFilter
}

"""
Application-level user record, keyed by wallet address,
used for referrals and other per-wallet metadata.
"""
type User {
  _count: UserCount

  """Canonical Ethereum wallet address for this user."""
  address: String!
  createdAt: DateTimeISO!
  id: Int!

  """
  Maximum number of referrals this user's code allows. Default is 0,
  so codes are not usable until explicitly configured.
  """
  maxReferrals: Int!

  """keccak256(utf8(trimmed_lowercase_code)) stored as 0x-prefixed hex."""
  refCodeHash: String
  referrals(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  referredBy(where: UserWhereInput): User
  referredById: Int
  updatedAt: DateTimeISO!
}

type UserAvgAggregate {
  id: Float
  maxReferrals: Float
  referredById: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

type UserCount {
  referrals(where: UserWhereInput): Int!
}

type UserCountAggregate {
  _all: Int!
  address: Int!
  createdAt: Int!
  id: Int!
  maxReferrals: Int!
  refCodeHash: Int!
  referredById: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrder
  referredById: SortOrder
  updatedAt: SortOrder
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  address: String!
  createdAt: DateTimeISO!
  id: Int!
  maxReferrals: Int!
  refCodeHash: String
  referredById: Int
  updatedAt: DateTimeISO!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  address: String
  createdAt: DateTimeISO
  id: Int
  maxReferrals: Int
  refCodeHash: String
  referredById: Int
  updatedAt: DateTimeISO
}

input UserMaxOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrder
  referredById: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  address: String
  createdAt: DateTimeISO
  id: Int
  maxReferrals: Int
  refCodeHash: String
  referredById: Int
  updatedAt: DateTimeISO
}

input UserMinOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrder
  referredById: SortOrder
  updatedAt: SortOrder
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrderInput
  referredById: SortOrderInput
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrderInput
  referrals: UserOrderByRelationAggregateInput
  referredBy: UserOrderByWithRelationInput
  referredById: SortOrderInput
  updatedAt: SortOrder
}

enum UserScalarFieldEnum {
  address
  createdAt
  id
  maxReferrals
  refCodeHash
  referredById
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  maxReferrals: IntWithAggregatesFilter
  refCodeHash: StringNullableWithAggregatesFilter
  referredById: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
  maxReferrals: Int
  referredById: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  maxReferrals: IntFilter
  refCodeHash: StringNullableFilter
  referrals: UserListRelationFilter
  referredBy: UserNullableRelationFilter
  referredById: IntNullableFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: String
  createdAt: DateTimeFilter
  id: Int
  maxReferrals: IntFilter
  refCodeHash: String
  referrals: UserListRelationFilter
  referredBy: UserNullableRelationFilter
  referredById: IntNullableFilter
  updatedAt: DateTimeFilter
}

enum transaction_type_enum {
  addLiquidity
  burnParlayNFTs
  long
  mintParlayNFTs
  removeLiquidity
  settledPosition
  short
}