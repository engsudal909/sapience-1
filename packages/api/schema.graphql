type Query {
  aggregateAttestation(where: AttestationWhereInput, orderBy: [AttestationOrderByWithRelationInput!], cursor: AttestationWhereUniqueInput, take: Int, skip: Int): AggregateAttestation!
  findFirstAttestation(where: AttestationWhereInput, orderBy: [AttestationOrderByWithRelationInput!], cursor: AttestationWhereUniqueInput, take: Int, skip: Int, distinct: [AttestationScalarFieldEnum!]): Attestation
  findFirstAttestationOrThrow(where: AttestationWhereInput, orderBy: [AttestationOrderByWithRelationInput!], cursor: AttestationWhereUniqueInput, take: Int, skip: Int, distinct: [AttestationScalarFieldEnum!]): Attestation
  attestations(where: AttestationWhereInput, orderBy: [AttestationOrderByWithRelationInput!], cursor: AttestationWhereUniqueInput, take: Int, skip: Int, distinct: [AttestationScalarFieldEnum!]): [Attestation!]!
  attestation(where: AttestationWhereUniqueInput!): Attestation
  getAttestation(where: AttestationWhereUniqueInput!): Attestation
  groupByAttestation(where: AttestationWhereInput, orderBy: [AttestationOrderByWithAggregationInput!], by: [AttestationScalarFieldEnum!]!, having: AttestationScalarWhereWithAggregatesInput, take: Int, skip: Int): [AttestationGroupBy!]!
  aggregateCategory(where: CategoryWhereInput, orderBy: [CategoryOrderByWithRelationInput!], cursor: CategoryWhereUniqueInput, take: Int, skip: Int): AggregateCategory!
  findFirstCategory(where: CategoryWhereInput, orderBy: [CategoryOrderByWithRelationInput!], cursor: CategoryWhereUniqueInput, take: Int, skip: Int, distinct: [CategoryScalarFieldEnum!]): Category
  findFirstCategoryOrThrow(where: CategoryWhereInput, orderBy: [CategoryOrderByWithRelationInput!], cursor: CategoryWhereUniqueInput, take: Int, skip: Int, distinct: [CategoryScalarFieldEnum!]): Category
  categories(where: CategoryWhereInput, orderBy: [CategoryOrderByWithRelationInput!], cursor: CategoryWhereUniqueInput, take: Int, skip: Int, distinct: [CategoryScalarFieldEnum!]): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  getCategory(where: CategoryWhereUniqueInput!): Category
  groupByCategory(where: CategoryWhereInput, orderBy: [CategoryOrderByWithAggregationInput!], by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, take: Int, skip: Int): [CategoryGroupBy!]!
  aggregateCondition(where: ConditionWhereInput, orderBy: [ConditionOrderByWithRelationInput!], cursor: ConditionWhereUniqueInput, take: Int, skip: Int): AggregateCondition!
  findFirstCondition(where: ConditionWhereInput, orderBy: [ConditionOrderByWithRelationInput!], cursor: ConditionWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionScalarFieldEnum!]): Condition
  findFirstConditionOrThrow(where: ConditionWhereInput, orderBy: [ConditionOrderByWithRelationInput!], cursor: ConditionWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionScalarFieldEnum!]): Condition
  conditions(where: ConditionWhereInput, orderBy: [ConditionOrderByWithRelationInput!], cursor: ConditionWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionScalarFieldEnum!]): [Condition!]!
  condition(where: ConditionWhereUniqueInput!): Condition
  getCondition(where: ConditionWhereUniqueInput!): Condition
  groupByCondition(where: ConditionWhereInput, orderBy: [ConditionOrderByWithAggregationInput!], by: [ConditionScalarFieldEnum!]!, having: ConditionScalarWhereWithAggregatesInput, take: Int, skip: Int): [ConditionGroupBy!]!
  aggregateConditionGroup(where: ConditionGroupWhereInput, orderBy: [ConditionGroupOrderByWithRelationInput!], cursor: ConditionGroupWhereUniqueInput, take: Int, skip: Int): AggregateConditionGroup!
  findFirstConditionGroup(where: ConditionGroupWhereInput, orderBy: [ConditionGroupOrderByWithRelationInput!], cursor: ConditionGroupWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionGroupScalarFieldEnum!]): ConditionGroup
  findFirstConditionGroupOrThrow(where: ConditionGroupWhereInput, orderBy: [ConditionGroupOrderByWithRelationInput!], cursor: ConditionGroupWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionGroupScalarFieldEnum!]): ConditionGroup
  conditionGroups(where: ConditionGroupWhereInput, orderBy: [ConditionGroupOrderByWithRelationInput!], cursor: ConditionGroupWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionGroupScalarFieldEnum!]): [ConditionGroup!]!
  conditionGroup(where: ConditionGroupWhereUniqueInput!): ConditionGroup
  getConditionGroup(where: ConditionGroupWhereUniqueInput!): ConditionGroup
  groupByConditionGroup(where: ConditionGroupWhereInput, orderBy: [ConditionGroupOrderByWithAggregationInput!], by: [ConditionGroupScalarFieldEnum!]!, having: ConditionGroupScalarWhereWithAggregatesInput, take: Int, skip: Int): [ConditionGroupGroupBy!]!
  aggregateUser(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int): AggregateUser!
  findFirstUser(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!]): User
  findFirstUserOrThrow(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!]): User
  users(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!]): [User!]!
  user(where: UserWhereUniqueInput!): User
  getUser(where: UserWhereUniqueInput!): User
  groupByUser(where: UserWhereInput, orderBy: [UserOrderByWithAggregationInput!], by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, take: Int, skip: Int): [UserGroupBy!]!
  getLeaderboard(marketAddress: String!, chainId: Int!): [PnLType!]!
  allTimeProfitLeaderboard: [AggregatedProfitEntryType!]!
  profitRankByAddress(owner: String!): ProfitRankType!
  forecasterScore(attester: String!): ForecasterScoreType
  topForecasters(limit: Int! = 10): [ForecasterScoreType!]!
  accuracyRankByAddress(attester: String!): AccuracyRankType!
  positionsCount(chainId: Int, address: String!): Int!
  positions(endsAtGte: Int, status: String, chainId: Int, orderDirection: String, orderBy: String, skip: Int! = 0, take: Int! = 50, address: String!): [PositionType!]!
  positionsByConditionId(endsAtGte: Int, status: String, chainId: Int, skip: Int! = 0, take: Int! = 100, conditionId: String!): [PositionType!]!
}

type AggregateAttestation {
  _count: AttestationCountAggregate
  _avg: AttestationAvgAggregate
  _sum: AttestationSumAggregate
  _min: AttestationMinAggregate
  _max: AttestationMaxAggregate
}

type AttestationCountAggregate {
  id: Int!
  createdAt: Int!
  uid: Int!
  attester: Int!
  recipient: Int!
  time: Int!
  blockNumber: Int!
  transactionHash: Int!
  schemaId: Int!
  data: Int!
  decodedDataJson: Int!
  marketAddress: Int!
  marketId: Int!
  questionId: Int!
  resolver: Int!
  condition: Int!
  prediction: Int!
  comment: Int!
  _all: Int!
}

type AttestationAvgAggregate {
  id: Float
  time: Float
  blockNumber: Float
}

type AttestationSumAggregate {
  id: Int
  time: Int
  blockNumber: Int
}

type AttestationMinAggregate {
  id: Int
  createdAt: DateTimeISO
  uid: String
  attester: String
  recipient: String
  time: Int
  blockNumber: Int
  transactionHash: String
  schemaId: String
  data: String
  decodedDataJson: String
  marketAddress: String
  marketId: String
  questionId: String
  resolver: String
  condition: String
  prediction: String
  comment: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type AttestationMaxAggregate {
  id: Int
  createdAt: DateTimeISO
  uid: String
  attester: String
  recipient: String
  time: Int
  blockNumber: Int
  transactionHash: String
  schemaId: String
  data: String
  decodedDataJson: String
  marketAddress: String
  marketId: String
  questionId: String
  resolver: String
  condition: String
  prediction: String
  comment: String
}

input AttestationWhereInput {
  AND: [AttestationWhereInput!]
  OR: [AttestationWhereInput!]
  NOT: [AttestationWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  uid: StringFilter
  attester: StringFilter
  recipient: StringFilter
  time: IntFilter
  blockNumber: IntFilter
  transactionHash: StringFilter
  schemaId: StringFilter
  data: StringFilter
  decodedDataJson: StringFilter
  marketAddress: StringNullableFilter
  marketId: StringNullableFilter
  questionId: StringNullableFilter
  resolver: StringNullableFilter
  condition: StringNullableFilter
  prediction: StringFilter
  comment: StringNullableFilter
  attestation_score: AttestationScoreNullableRelationFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input StringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableFilter
}

input NestedStringNullableFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableFilter
}

input AttestationScoreNullableRelationFilter {
  is: AttestationScoreWhereInput
  isNot: AttestationScoreWhereInput
}

input AttestationScoreWhereInput {
  AND: [AttestationScoreWhereInput!]
  OR: [AttestationScoreWhereInput!]
  NOT: [AttestationScoreWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  attestationId: IntFilter
  attester: StringFilter
  marketAddress: StringNullableFilter
  marketId: StringNullableFilter
  questionId: StringNullableFilter
  resolver: StringNullableFilter
  madeAt: IntFilter
  used: BoolFilter
  probabilityD18: StringNullableFilter
  probabilityFloat: FloatNullableFilter
  outcome: IntNullableFilter
  errorSquared: FloatNullableFilter
  scoredAt: DateTimeNullableFilter
  attestation: AttestationRelationFilter
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input FloatNullableFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatNullableFilter
}

input NestedFloatNullableFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatNullableFilter
}

input IntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableFilter
}

input NestedIntNullableFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableFilter
}

input DateTimeNullableFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeNullableFilter
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeNullableFilter
}

input AttestationRelationFilter {
  is: AttestationWhereInput
  isNot: AttestationWhereInput
}

input AttestationOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  uid: SortOrder
  attester: SortOrder
  recipient: SortOrder
  time: SortOrder
  blockNumber: SortOrder
  transactionHash: SortOrder
  schemaId: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  marketAddress: SortOrderInput
  marketId: SortOrderInput
  questionId: SortOrderInput
  resolver: SortOrderInput
  condition: SortOrderInput
  prediction: SortOrder
  comment: SortOrderInput
  attestation_score: AttestationScoreOrderByWithRelationInput
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  sort: SortOrder!
  nulls: NullsOrder
}

enum NullsOrder {
  first
  last
}

input AttestationScoreOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  attestationId: SortOrder
  attester: SortOrder
  marketAddress: SortOrderInput
  marketId: SortOrderInput
  questionId: SortOrderInput
  resolver: SortOrderInput
  madeAt: SortOrder
  used: SortOrder
  probabilityD18: SortOrderInput
  probabilityFloat: SortOrderInput
  outcome: SortOrderInput
  errorSquared: SortOrderInput
  scoredAt: SortOrderInput
  attestation: AttestationOrderByWithRelationInput
}

input AttestationWhereUniqueInput {
  id: Int
  uid: String
  AND: [AttestationWhereInput!]
  OR: [AttestationWhereInput!]
  NOT: [AttestationWhereInput!]
  createdAt: DateTimeFilter
  attester: StringFilter
  recipient: StringFilter
  time: IntFilter
  blockNumber: IntFilter
  transactionHash: StringFilter
  schemaId: StringFilter
  data: StringFilter
  decodedDataJson: StringFilter
  marketAddress: StringNullableFilter
  marketId: StringNullableFilter
  questionId: StringNullableFilter
  resolver: StringNullableFilter
  condition: StringNullableFilter
  prediction: StringFilter
  comment: StringNullableFilter
  attestation_score: AttestationScoreNullableRelationFilter
}

type Attestation {
  id: Int!
  createdAt: DateTimeISO!
  uid: String!
  attester: String!
  recipient: String!
  time: Int!
  blockNumber: Int!
  transactionHash: String!
  schemaId: String!
  data: String!
  decodedDataJson: String!
  marketAddress: String
  marketId: String
  questionId: String
  resolver: String
  condition: String
  prediction: String!
  comment: String
  attestation_score(where: AttestationScoreWhereInput): AttestationScore
}

type AttestationScore {
  id: Int!
  createdAt: DateTimeISO!
  attestationId: Int!
  attester: String!
  marketAddress: String
  marketId: String
  questionId: String
  resolver: String
  madeAt: Int!
  used: Boolean!
  probabilityD18: String
  probabilityFloat: Float
  outcome: Int
  errorSquared: Float
  scoredAt: DateTimeISO
  attestation: Attestation!
}

enum AttestationScalarFieldEnum {
  id
  createdAt
  uid
  attester
  recipient
  time
  blockNumber
  transactionHash
  schemaId
  data
  decodedDataJson
  marketAddress
  marketId
  questionId
  resolver
  condition
  prediction
  comment
}

type AttestationGroupBy {
  id: Int!
  createdAt: DateTimeISO!
  uid: String!
  attester: String!
  recipient: String!
  time: Int!
  blockNumber: Int!
  transactionHash: String!
  schemaId: String!
  data: String!
  decodedDataJson: String!
  marketAddress: String
  marketId: String
  questionId: String
  resolver: String
  condition: String
  prediction: String!
  comment: String
  _count: AttestationCountAggregate
  _avg: AttestationAvgAggregate
  _sum: AttestationSumAggregate
  _min: AttestationMinAggregate
  _max: AttestationMaxAggregate
}

input AttestationOrderByWithAggregationInput {
  id: SortOrder
  createdAt: SortOrder
  uid: SortOrder
  attester: SortOrder
  recipient: SortOrder
  time: SortOrder
  blockNumber: SortOrder
  transactionHash: SortOrder
  schemaId: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  marketAddress: SortOrderInput
  marketId: SortOrderInput
  questionId: SortOrderInput
  resolver: SortOrderInput
  condition: SortOrderInput
  prediction: SortOrder
  comment: SortOrderInput
  _count: AttestationCountOrderByAggregateInput
  _avg: AttestationAvgOrderByAggregateInput
  _max: AttestationMaxOrderByAggregateInput
  _min: AttestationMinOrderByAggregateInput
  _sum: AttestationSumOrderByAggregateInput
}

input AttestationCountOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  uid: SortOrder
  attester: SortOrder
  recipient: SortOrder
  time: SortOrder
  blockNumber: SortOrder
  transactionHash: SortOrder
  schemaId: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  questionId: SortOrder
  resolver: SortOrder
  condition: SortOrder
  prediction: SortOrder
  comment: SortOrder
}

input AttestationAvgOrderByAggregateInput {
  id: SortOrder
  time: SortOrder
  blockNumber: SortOrder
}

input AttestationMaxOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  uid: SortOrder
  attester: SortOrder
  recipient: SortOrder
  time: SortOrder
  blockNumber: SortOrder
  transactionHash: SortOrder
  schemaId: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  questionId: SortOrder
  resolver: SortOrder
  condition: SortOrder
  prediction: SortOrder
  comment: SortOrder
}

input AttestationMinOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  uid: SortOrder
  attester: SortOrder
  recipient: SortOrder
  time: SortOrder
  blockNumber: SortOrder
  transactionHash: SortOrder
  schemaId: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  questionId: SortOrder
  resolver: SortOrder
  condition: SortOrder
  prediction: SortOrder
  comment: SortOrder
}

input AttestationSumOrderByAggregateInput {
  id: SortOrder
  time: SortOrder
  blockNumber: SortOrder
}

input AttestationScalarWhereWithAggregatesInput {
  AND: [AttestationScalarWhereWithAggregatesInput!]
  OR: [AttestationScalarWhereWithAggregatesInput!]
  NOT: [AttestationScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  uid: StringWithAggregatesFilter
  attester: StringWithAggregatesFilter
  recipient: StringWithAggregatesFilter
  time: IntWithAggregatesFilter
  blockNumber: IntWithAggregatesFilter
  transactionHash: StringWithAggregatesFilter
  schemaId: StringWithAggregatesFilter
  data: StringWithAggregatesFilter
  decodedDataJson: StringWithAggregatesFilter
  marketAddress: StringNullableWithAggregatesFilter
  marketId: StringNullableWithAggregatesFilter
  questionId: StringNullableWithAggregatesFilter
  resolver: StringNullableWithAggregatesFilter
  condition: StringNullableWithAggregatesFilter
  prediction: StringWithAggregatesFilter
  comment: StringNullableWithAggregatesFilter
}

input IntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input DateTimeWithAggregatesFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

input NestedDateTimeWithAggregatesFilter {
  equals: DateTimeISO
  in: [DateTimeISO!]
  notIn: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

input StringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input NestedStringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input StringNullableWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedStringNullableFilter
  _max: NestedStringNullableFilter
}

input NestedStringNullableWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _min: NestedStringNullableFilter
  _max: NestedStringNullableFilter
}

type AggregateCategory {
  _count: CategoryCountAggregate
  _avg: CategoryAvgAggregate
  _sum: CategorySumAggregate
  _min: CategoryMinAggregate
  _max: CategoryMaxAggregate
}

type CategoryCountAggregate {
  id: Int!
  createdAt: Int!
  name: Int!
  slug: Int!
  _all: Int!
}

type CategoryAvgAggregate {
  id: Float
}

type CategorySumAggregate {
  id: Int
}

type CategoryMinAggregate {
  id: Int
  createdAt: DateTimeISO
  name: String
  slug: String
}

type CategoryMaxAggregate {
  id: Int
  createdAt: DateTimeISO
  name: String
  slug: String
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  name: StringFilter
  slug: StringFilter
  conditions: ConditionListRelationFilter
  conditionGroups: ConditionGroupListRelationFilter
}

input ConditionListRelationFilter {
  every: ConditionWhereInput
  some: ConditionWhereInput
  none: ConditionWhereInput
}

input ConditionWhereInput {
  AND: [ConditionWhereInput!]
  OR: [ConditionWhereInput!]
  NOT: [ConditionWhereInput!]
  id: StringFilter
  createdAt: DateTimeFilter
  question: StringFilter
  shortName: StringNullableFilter
  categoryId: IntNullableFilter
  endTime: IntFilter
  public: BoolFilter
  claimStatement: StringFilter
  description: StringFilter
  similarMarkets: StringNullableListFilter
  chainId: IntFilter
  openInterest: StringFilter
  resolver: StringNullableFilter
  settled: BoolFilter
  resolvedToYes: BoolFilter
  settledAt: IntNullableFilter
  assertionId: StringNullableFilter
  assertionTimestamp: IntNullableFilter
  conditionGroupId: IntNullableFilter
  displayOrder: IntNullableFilter
  category: CategoryNullableRelationFilter
  conditionGroup: ConditionGroupNullableRelationFilter
  predictions: PredictionListRelationFilter
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input CategoryNullableRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

input ConditionGroupNullableRelationFilter {
  is: ConditionGroupWhereInput
  isNot: ConditionGroupWhereInput
}

input ConditionGroupWhereInput {
  AND: [ConditionGroupWhereInput!]
  OR: [ConditionGroupWhereInput!]
  NOT: [ConditionGroupWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  name: StringFilter
  categoryId: IntNullableFilter
  category: CategoryNullableRelationFilter
  conditions: ConditionListRelationFilter
}

input PredictionListRelationFilter {
  every: PredictionWhereInput
  some: PredictionWhereInput
  none: PredictionWhereInput
}

input PredictionWhereInput {
  AND: [PredictionWhereInput!]
  OR: [PredictionWhereInput!]
  NOT: [PredictionWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  conditionId: StringFilter
  positionId: IntNullableFilter
  limitOrderId: IntNullableFilter
  outcomeYes: BoolFilter
  chainId: IntNullableFilter
  condition: ConditionRelationFilter
  position: PositionNullableRelationFilter
  limitOrder: LimitOrderNullableRelationFilter
}

input ConditionRelationFilter {
  is: ConditionWhereInput
  isNot: ConditionWhereInput
}

input PositionNullableRelationFilter {
  is: PositionWhereInput
  isNot: PositionWhereInput
}

input PositionWhereInput {
  AND: [PositionWhereInput!]
  OR: [PositionWhereInput!]
  NOT: [PositionWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  chainId: IntFilter
  marketAddress: StringFilter
  predictor: StringFilter
  counterparty: StringFilter
  predictorNftTokenId: StringFilter
  counterpartyNftTokenId: StringFilter
  totalCollateral: StringFilter
  predictorCollateral: StringNullableFilter
  counterpartyCollateral: StringNullableFilter
  refCode: StringNullableFilter
  status: EnumPositionStatusFilter
  predictorWon: BoolNullableFilter
  mintedAt: IntFilter
  settledAt: IntNullableFilter
  endsAt: IntNullableFilter
  predictions: PredictionListRelationFilter
}

input EnumPositionStatusFilter {
  equals: PositionStatus
  in: [PositionStatus!]
  notIn: [PositionStatus!]
  not: NestedEnumPositionStatusFilter
}

enum PositionStatus {
  active
  settled
  consolidated
}

input NestedEnumPositionStatusFilter {
  equals: PositionStatus
  in: [PositionStatus!]
  notIn: [PositionStatus!]
  not: NestedEnumPositionStatusFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input LimitOrderNullableRelationFilter {
  is: LimitOrderWhereInput
  isNot: LimitOrderWhereInput
}

input LimitOrderWhereInput {
  AND: [LimitOrderWhereInput!]
  OR: [LimitOrderWhereInput!]
  NOT: [LimitOrderWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  chainId: IntFilter
  marketAddress: StringFilter
  orderId: StringFilter
  predictor: StringFilter
  resolver: StringFilter
  predictorCollateral: StringFilter
  counterpartyCollateral: StringFilter
  refCode: StringNullableFilter
  status: EnumLimitOrderStatusFilter
  placedAt: IntFilter
  filledAt: IntNullableFilter
  cancelledAt: IntNullableFilter
  counterparty: StringNullableFilter
  placedTxHash: StringFilter
  filledTxHash: StringNullableFilter
  cancelledTxHash: StringNullableFilter
  predictions: PredictionListRelationFilter
}

input EnumLimitOrderStatusFilter {
  equals: LimitOrderStatus
  in: [LimitOrderStatus!]
  notIn: [LimitOrderStatus!]
  not: NestedEnumLimitOrderStatusFilter
}

enum LimitOrderStatus {
  pending
  filled
  cancelled
}

input NestedEnumLimitOrderStatusFilter {
  equals: LimitOrderStatus
  in: [LimitOrderStatus!]
  notIn: [LimitOrderStatus!]
  not: NestedEnumLimitOrderStatusFilter
}

input ConditionGroupListRelationFilter {
  every: ConditionGroupWhereInput
  some: ConditionGroupWhereInput
  none: ConditionGroupWhereInput
}

input CategoryOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  slug: SortOrder
  conditions: ConditionOrderByRelationAggregateInput
  conditionGroups: ConditionGroupOrderByRelationAggregateInput
}

input ConditionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ConditionGroupOrderByRelationAggregateInput {
  _count: SortOrder
}

input CategoryWhereUniqueInput {
  id: Int
  name: String
  slug: String
  AND: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  createdAt: DateTimeFilter
  conditions: ConditionListRelationFilter
  conditionGroups: ConditionGroupListRelationFilter
}

type Category {
  id: Int!
  createdAt: DateTimeISO!
  name: String!
  slug: String!
  _count: CategoryCount
  conditions(where: ConditionWhereInput, orderBy: [ConditionOrderByWithRelationInput!], cursor: ConditionWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionScalarFieldEnum!]): [Condition!]!
  conditionGroups(where: ConditionGroupWhereInput, orderBy: [ConditionGroupOrderByWithRelationInput!], cursor: ConditionGroupWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionGroupScalarFieldEnum!]): [ConditionGroup!]!
}

type CategoryCount {
  condition(where: ConditionWhereInput): Int!
  condition_group(where: ConditionGroupWhereInput): Int!
}

type Condition {
  id: String!
  createdAt: DateTimeISO!
  question: String!
  shortName: String
  categoryId: Int
  endTime: Int!
  public: Boolean!
  claimStatement: String!
  description: String!
  similarMarkets: [String!]!
  chainId: Int!
  openInterest: String!

  """Canonical resolver address for this condition (latest observed wins)"""
  resolver: String
  settled: Boolean!
  resolvedToYes: Boolean!
  settledAt: Int
  assertionId: String
  assertionTimestamp: Int
  conditionGroupId: Int
  displayOrder: Int
  _count: ConditionCount
  category(where: CategoryWhereInput): Category
  conditionGroup(where: ConditionGroupWhereInput): ConditionGroup
  predictions(where: PredictionWhereInput, orderBy: [PredictionOrderByWithRelationInput!], cursor: PredictionWhereUniqueInput, take: Int, skip: Int, distinct: [PredictionScalarFieldEnum!]): [Prediction!]!
}

type ConditionCount {
  predictions(where: PredictionWhereInput): Int!
}

type ConditionGroup {
  id: Int!
  createdAt: DateTimeISO!
  name: String!
  categoryId: Int
  _count: ConditionGroupCount
  category(where: CategoryWhereInput): Category
  conditions(where: ConditionWhereInput, orderBy: [ConditionOrderByWithRelationInput!], cursor: ConditionWhereUniqueInput, take: Int, skip: Int, distinct: [ConditionScalarFieldEnum!]): [Condition!]!
}

type ConditionGroupCount {
  condition(where: ConditionWhereInput): Int!
}

input ConditionOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  question: SortOrder
  shortName: SortOrderInput
  categoryId: SortOrderInput
  endTime: SortOrder
  public: SortOrder
  claimStatement: SortOrder
  description: SortOrder
  similarMarkets: SortOrder
  chainId: SortOrder
  openInterest: SortOrder
  resolver: SortOrderInput
  settled: SortOrder
  resolvedToYes: SortOrder
  settledAt: SortOrderInput
  assertionId: SortOrderInput
  assertionTimestamp: SortOrderInput
  conditionGroupId: SortOrderInput
  displayOrder: SortOrderInput
  category: CategoryOrderByWithRelationInput
  conditionGroup: ConditionGroupOrderByWithRelationInput
  predictions: PredictionOrderByRelationAggregateInput
}

input ConditionGroupOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  categoryId: SortOrderInput
  category: CategoryOrderByWithRelationInput
  conditions: ConditionOrderByRelationAggregateInput
}

input PredictionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ConditionWhereUniqueInput {
  id: String
  AND: [ConditionWhereInput!]
  OR: [ConditionWhereInput!]
  NOT: [ConditionWhereInput!]
  createdAt: DateTimeFilter
  question: StringFilter
  shortName: StringNullableFilter
  categoryId: IntNullableFilter
  endTime: IntFilter
  public: BoolFilter
  claimStatement: StringFilter
  description: StringFilter
  similarMarkets: StringNullableListFilter
  chainId: IntFilter
  openInterest: StringFilter
  resolver: StringNullableFilter
  settled: BoolFilter
  resolvedToYes: BoolFilter
  settledAt: IntNullableFilter
  assertionId: StringNullableFilter
  assertionTimestamp: IntNullableFilter
  conditionGroupId: IntNullableFilter
  displayOrder: IntNullableFilter
  category: CategoryNullableRelationFilter
  conditionGroup: ConditionGroupNullableRelationFilter
  predictions: PredictionListRelationFilter
}

enum ConditionScalarFieldEnum {
  id
  createdAt
  question
  shortName
  categoryId
  endTime
  public
  claimStatement
  description
  similarMarkets
  chainId
  openInterest
  resolver
  settled
  resolvedToYes
  settledAt
  assertionId
  assertionTimestamp
  conditionGroupId
  displayOrder
}

type Prediction {
  id: Int!
  createdAt: DateTimeISO!
  conditionId: String!
  positionId: Int
  limitOrderId: Int
  outcomeYes: Boolean!
  chainId: Int
  condition: Condition!
  position(where: PositionWhereInput): Position
  limitOrder(where: LimitOrderWhereInput): LimitOrder
}

"""Position model to store on-chain prediction positions"""
type Position {
  id: Int!
  createdAt: DateTimeISO!
  chainId: Int!
  marketAddress: String!
  predictor: String!
  counterparty: String!
  predictorNftTokenId: String!
  counterpartyNftTokenId: String!
  totalCollateral: String!
  predictorCollateral: String
  counterpartyCollateral: String
  refCode: String
  status: PositionStatus!

  """
  True when the predictor's submitted outcomes were correct (previously makerWon)
  """
  predictorWon: Boolean
  mintedAt: Int!
  settledAt: Int
  endsAt: Int
  _count: PositionCount
  predictions(where: PredictionWhereInput, orderBy: [PredictionOrderByWithRelationInput!], cursor: PredictionWhereUniqueInput, take: Int, skip: Int, distinct: [PredictionScalarFieldEnum!]): [Prediction!]!
}

type PositionCount {
  predictions(where: PredictionWhereInput): Int!
}

input PredictionOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  conditionId: SortOrder
  positionId: SortOrderInput
  limitOrderId: SortOrderInput
  outcomeYes: SortOrder
  chainId: SortOrderInput
  condition: ConditionOrderByWithRelationInput
  position: PositionOrderByWithRelationInput
  limitOrder: LimitOrderOrderByWithRelationInput
}

input PositionOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  chainId: SortOrder
  marketAddress: SortOrder
  predictor: SortOrder
  counterparty: SortOrder
  predictorNftTokenId: SortOrder
  counterpartyNftTokenId: SortOrder
  totalCollateral: SortOrder
  predictorCollateral: SortOrderInput
  counterpartyCollateral: SortOrderInput
  refCode: SortOrderInput
  status: SortOrder
  predictorWon: SortOrderInput
  mintedAt: SortOrder
  settledAt: SortOrderInput
  endsAt: SortOrderInput
  predictions: PredictionOrderByRelationAggregateInput
}

input LimitOrderOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  chainId: SortOrder
  marketAddress: SortOrder
  orderId: SortOrder
  predictor: SortOrder
  resolver: SortOrder
  predictorCollateral: SortOrder
  counterpartyCollateral: SortOrder
  refCode: SortOrderInput
  status: SortOrder
  placedAt: SortOrder
  filledAt: SortOrderInput
  cancelledAt: SortOrderInput
  counterparty: SortOrderInput
  placedTxHash: SortOrder
  filledTxHash: SortOrderInput
  cancelledTxHash: SortOrderInput
  predictions: PredictionOrderByRelationAggregateInput
}

input PredictionWhereUniqueInput {
  id: Int
  positionId_conditionId: PredictionPositionIdConditionIdCompoundUniqueInput
  limitOrderId_conditionId: PredictionLimitOrderIdConditionIdCompoundUniqueInput
  AND: [PredictionWhereInput!]
  OR: [PredictionWhereInput!]
  NOT: [PredictionWhereInput!]
  createdAt: DateTimeFilter
  conditionId: StringFilter
  positionId: IntNullableFilter
  limitOrderId: IntNullableFilter
  outcomeYes: BoolFilter
  chainId: IntNullableFilter
  condition: ConditionRelationFilter
  position: PositionNullableRelationFilter
  limitOrder: LimitOrderNullableRelationFilter
}

input PredictionPositionIdConditionIdCompoundUniqueInput {
  positionId: Int!
  conditionId: String!
}

input PredictionLimitOrderIdConditionIdCompoundUniqueInput {
  limitOrderId: Int!
  conditionId: String!
}

enum PredictionScalarFieldEnum {
  id
  createdAt
  conditionId
  positionId
  limitOrderId
  outcomeYes
  chainId
}

type LimitOrder {
  id: Int!
  createdAt: DateTimeISO!
  chainId: Int!
  marketAddress: String!
  orderId: String!
  predictor: String!
  resolver: String!
  predictorCollateral: String!
  counterpartyCollateral: String!
  refCode: String
  status: LimitOrderStatus!
  placedAt: Int!
  filledAt: Int
  cancelledAt: Int
  counterparty: String
  placedTxHash: String!
  filledTxHash: String
  cancelledTxHash: String
  _count: LimitOrderCount
  predictions(where: PredictionWhereInput, orderBy: [PredictionOrderByWithRelationInput!], cursor: PredictionWhereUniqueInput, take: Int, skip: Int, distinct: [PredictionScalarFieldEnum!]): [Prediction!]!
}

type LimitOrderCount {
  predictions(where: PredictionWhereInput): Int!
}

input ConditionGroupWhereUniqueInput {
  id: Int
  name: String
  AND: [ConditionGroupWhereInput!]
  OR: [ConditionGroupWhereInput!]
  NOT: [ConditionGroupWhereInput!]
  createdAt: DateTimeFilter
  categoryId: IntNullableFilter
  category: CategoryNullableRelationFilter
  conditions: ConditionListRelationFilter
}

enum ConditionGroupScalarFieldEnum {
  id
  createdAt
  name
  categoryId
}

enum CategoryScalarFieldEnum {
  id
  createdAt
  name
  slug
}

type CategoryGroupBy {
  id: Int!
  createdAt: DateTimeISO!
  name: String!
  slug: String!
  _count: CategoryCountAggregate
  _avg: CategoryAvgAggregate
  _sum: CategorySumAggregate
  _min: CategoryMinAggregate
  _max: CategoryMaxAggregate
}

input CategoryOrderByWithAggregationInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  slug: SortOrder
  _count: CategoryCountOrderByAggregateInput
  _avg: CategoryAvgOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
}

input CategoryCountOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryAvgOrderByAggregateInput {
  id: SortOrder
}

input CategoryMaxOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryMinOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategorySumOrderByAggregateInput {
  id: SortOrder
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  name: StringWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

type AggregateCondition {
  _count: ConditionCountAggregate
  _avg: ConditionAvgAggregate
  _sum: ConditionSumAggregate
  _min: ConditionMinAggregate
  _max: ConditionMaxAggregate
}

type ConditionCountAggregate {
  id: Int!
  createdAt: Int!
  question: Int!
  shortName: Int!
  categoryId: Int!
  endTime: Int!
  public: Int!
  claimStatement: Int!
  description: Int!
  similarMarkets: Int!
  chainId: Int!
  openInterest: Int!
  resolver: Int!
  settled: Int!
  resolvedToYes: Int!
  settledAt: Int!
  assertionId: Int!
  assertionTimestamp: Int!
  conditionGroupId: Int!
  displayOrder: Int!
  _all: Int!
}

type ConditionAvgAggregate {
  categoryId: Float
  endTime: Float
  chainId: Float
  settledAt: Float
  assertionTimestamp: Float
  conditionGroupId: Float
  displayOrder: Float
}

type ConditionSumAggregate {
  categoryId: Int
  endTime: Int
  chainId: Int
  settledAt: Int
  assertionTimestamp: Int
  conditionGroupId: Int
  displayOrder: Int
}

type ConditionMinAggregate {
  id: String
  createdAt: DateTimeISO
  question: String
  shortName: String
  categoryId: Int
  endTime: Int
  public: Boolean
  claimStatement: String
  description: String
  chainId: Int
  openInterest: String
  resolver: String
  settled: Boolean
  resolvedToYes: Boolean
  settledAt: Int
  assertionId: String
  assertionTimestamp: Int
  conditionGroupId: Int
  displayOrder: Int
}

type ConditionMaxAggregate {
  id: String
  createdAt: DateTimeISO
  question: String
  shortName: String
  categoryId: Int
  endTime: Int
  public: Boolean
  claimStatement: String
  description: String
  chainId: Int
  openInterest: String
  resolver: String
  settled: Boolean
  resolvedToYes: Boolean
  settledAt: Int
  assertionId: String
  assertionTimestamp: Int
  conditionGroupId: Int
  displayOrder: Int
}

type ConditionGroupBy {
  id: String!
  createdAt: DateTimeISO!
  question: String!
  shortName: String
  categoryId: Int
  endTime: Int!
  public: Boolean!
  claimStatement: String!
  description: String!
  similarMarkets: [String!]
  chainId: Int!
  openInterest: String!
  resolver: String
  settled: Boolean!
  resolvedToYes: Boolean!
  settledAt: Int
  assertionId: String
  assertionTimestamp: Int
  conditionGroupId: Int
  displayOrder: Int
  _count: ConditionCountAggregate
  _avg: ConditionAvgAggregate
  _sum: ConditionSumAggregate
  _min: ConditionMinAggregate
  _max: ConditionMaxAggregate
}

input ConditionOrderByWithAggregationInput {
  id: SortOrder
  createdAt: SortOrder
  question: SortOrder
  shortName: SortOrderInput
  categoryId: SortOrderInput
  endTime: SortOrder
  public: SortOrder
  claimStatement: SortOrder
  description: SortOrder
  similarMarkets: SortOrder
  chainId: SortOrder
  openInterest: SortOrder
  resolver: SortOrderInput
  settled: SortOrder
  resolvedToYes: SortOrder
  settledAt: SortOrderInput
  assertionId: SortOrderInput
  assertionTimestamp: SortOrderInput
  conditionGroupId: SortOrderInput
  displayOrder: SortOrderInput
  _count: ConditionCountOrderByAggregateInput
  _avg: ConditionAvgOrderByAggregateInput
  _max: ConditionMaxOrderByAggregateInput
  _min: ConditionMinOrderByAggregateInput
  _sum: ConditionSumOrderByAggregateInput
}

input ConditionCountOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  question: SortOrder
  shortName: SortOrder
  categoryId: SortOrder
  endTime: SortOrder
  public: SortOrder
  claimStatement: SortOrder
  description: SortOrder
  similarMarkets: SortOrder
  chainId: SortOrder
  openInterest: SortOrder
  resolver: SortOrder
  settled: SortOrder
  resolvedToYes: SortOrder
  settledAt: SortOrder
  assertionId: SortOrder
  assertionTimestamp: SortOrder
  conditionGroupId: SortOrder
  displayOrder: SortOrder
}

input ConditionAvgOrderByAggregateInput {
  categoryId: SortOrder
  endTime: SortOrder
  chainId: SortOrder
  settledAt: SortOrder
  assertionTimestamp: SortOrder
  conditionGroupId: SortOrder
  displayOrder: SortOrder
}

input ConditionMaxOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  question: SortOrder
  shortName: SortOrder
  categoryId: SortOrder
  endTime: SortOrder
  public: SortOrder
  claimStatement: SortOrder
  description: SortOrder
  chainId: SortOrder
  openInterest: SortOrder
  resolver: SortOrder
  settled: SortOrder
  resolvedToYes: SortOrder
  settledAt: SortOrder
  assertionId: SortOrder
  assertionTimestamp: SortOrder
  conditionGroupId: SortOrder
  displayOrder: SortOrder
}

input ConditionMinOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  question: SortOrder
  shortName: SortOrder
  categoryId: SortOrder
  endTime: SortOrder
  public: SortOrder
  claimStatement: SortOrder
  description: SortOrder
  chainId: SortOrder
  openInterest: SortOrder
  resolver: SortOrder
  settled: SortOrder
  resolvedToYes: SortOrder
  settledAt: SortOrder
  assertionId: SortOrder
  assertionTimestamp: SortOrder
  conditionGroupId: SortOrder
  displayOrder: SortOrder
}

input ConditionSumOrderByAggregateInput {
  categoryId: SortOrder
  endTime: SortOrder
  chainId: SortOrder
  settledAt: SortOrder
  assertionTimestamp: SortOrder
  conditionGroupId: SortOrder
  displayOrder: SortOrder
}

input ConditionScalarWhereWithAggregatesInput {
  AND: [ConditionScalarWhereWithAggregatesInput!]
  OR: [ConditionScalarWhereWithAggregatesInput!]
  NOT: [ConditionScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  question: StringWithAggregatesFilter
  shortName: StringNullableWithAggregatesFilter
  categoryId: IntNullableWithAggregatesFilter
  endTime: IntWithAggregatesFilter
  public: BoolWithAggregatesFilter
  claimStatement: StringWithAggregatesFilter
  description: StringWithAggregatesFilter
  similarMarkets: StringNullableListFilter
  chainId: IntWithAggregatesFilter
  openInterest: StringWithAggregatesFilter
  resolver: StringNullableWithAggregatesFilter
  settled: BoolWithAggregatesFilter
  resolvedToYes: BoolWithAggregatesFilter
  settledAt: IntNullableWithAggregatesFilter
  assertionId: StringNullableWithAggregatesFilter
  assertionTimestamp: IntNullableWithAggregatesFilter
  conditionGroupId: IntNullableWithAggregatesFilter
  displayOrder: IntNullableWithAggregatesFilter
}

input IntNullableWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _avg: NestedFloatNullableFilter
  _sum: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _max: NestedIntNullableFilter
}

input NestedIntNullableWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntNullableWithAggregatesFilter
  _count: NestedIntNullableFilter
  _avg: NestedFloatNullableFilter
  _sum: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _max: NestedIntNullableFilter
}

input BoolWithAggregatesFilter {
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedBoolFilter
  _max: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedBoolFilter
  _max: NestedBoolFilter
}

type AggregateConditionGroup {
  _count: ConditionGroupCountAggregate
  _avg: ConditionGroupAvgAggregate
  _sum: ConditionGroupSumAggregate
  _min: ConditionGroupMinAggregate
  _max: ConditionGroupMaxAggregate
}

type ConditionGroupCountAggregate {
  id: Int!
  createdAt: Int!
  name: Int!
  categoryId: Int!
  _all: Int!
}

type ConditionGroupAvgAggregate {
  id: Float
  categoryId: Float
}

type ConditionGroupSumAggregate {
  id: Int
  categoryId: Int
}

type ConditionGroupMinAggregate {
  id: Int
  createdAt: DateTimeISO
  name: String
  categoryId: Int
}

type ConditionGroupMaxAggregate {
  id: Int
  createdAt: DateTimeISO
  name: String
  categoryId: Int
}

type ConditionGroupGroupBy {
  id: Int!
  createdAt: DateTimeISO!
  name: String!
  categoryId: Int
  _count: ConditionGroupCountAggregate
  _avg: ConditionGroupAvgAggregate
  _sum: ConditionGroupSumAggregate
  _min: ConditionGroupMinAggregate
  _max: ConditionGroupMaxAggregate
}

input ConditionGroupOrderByWithAggregationInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  categoryId: SortOrderInput
  _count: ConditionGroupCountOrderByAggregateInput
  _avg: ConditionGroupAvgOrderByAggregateInput
  _max: ConditionGroupMaxOrderByAggregateInput
  _min: ConditionGroupMinOrderByAggregateInput
  _sum: ConditionGroupSumOrderByAggregateInput
}

input ConditionGroupCountOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  categoryId: SortOrder
}

input ConditionGroupAvgOrderByAggregateInput {
  id: SortOrder
  categoryId: SortOrder
}

input ConditionGroupMaxOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  categoryId: SortOrder
}

input ConditionGroupMinOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  name: SortOrder
  categoryId: SortOrder
}

input ConditionGroupSumOrderByAggregateInput {
  id: SortOrder
  categoryId: SortOrder
}

input ConditionGroupScalarWhereWithAggregatesInput {
  AND: [ConditionGroupScalarWhereWithAggregatesInput!]
  OR: [ConditionGroupScalarWhereWithAggregatesInput!]
  NOT: [ConditionGroupScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  name: StringWithAggregatesFilter
  categoryId: IntNullableWithAggregatesFilter
}

type AggregateUser {
  _count: UserCountAggregate
  _avg: UserAvgAggregate
  _sum: UserSumAggregate
  _min: UserMinAggregate
  _max: UserMaxAggregate
}

type UserCountAggregate {
  id: Int!
  createdAt: Int!
  updatedAt: Int!
  address: Int!
  refCodeHash: Int!
  maxReferrals: Int!
  referredById: Int!
  _all: Int!
}

type UserAvgAggregate {
  id: Float
  maxReferrals: Float
  referredById: Float
}

type UserSumAggregate {
  id: Int
  maxReferrals: Int
  referredById: Int
}

type UserMinAggregate {
  id: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  address: String
  refCodeHash: String
  maxReferrals: Int
  referredById: Int
}

type UserMaxAggregate {
  id: Int
  createdAt: DateTimeISO
  updatedAt: DateTimeISO
  address: String
  refCodeHash: String
  maxReferrals: Int
  referredById: Int
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IntFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  address: StringFilter
  refCodeHash: StringNullableFilter
  maxReferrals: IntFilter
  referredById: IntNullableFilter
  referredBy: UserNullableRelationFilter
  referrals: UserListRelationFilter
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserListRelationFilter {
  every: UserWhereInput
  some: UserWhereInput
  none: UserWhereInput
}

input UserOrderByWithRelationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  address: SortOrder
  refCodeHash: SortOrderInput
  maxReferrals: SortOrder
  referredById: SortOrderInput
  referredBy: UserOrderByWithRelationInput
  referrals: UserOrderByRelationAggregateInput
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserWhereUniqueInput {
  id: Int
  address: String
  refCodeHash: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  maxReferrals: IntFilter
  referredById: IntNullableFilter
  referredBy: UserNullableRelationFilter
  referrals: UserListRelationFilter
}

"""
Application-level user record, keyed by wallet address,
used for referrals and other per-wallet metadata.
"""
type User {
  id: Int!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!

  """Canonical Ethereum wallet address for this user."""
  address: String!

  """keccak256(utf8(trimmed_lowercase_code)) stored as 0x-prefixed hex."""
  refCodeHash: String

  """
  Maximum number of referrals this user's code allows. Default is 0,
  so codes are not usable until explicitly configured.
  """
  maxReferrals: Int!
  referredById: Int
  _count: UserCount
  referredBy(where: UserWhereInput): User
  referrals(where: UserWhereInput, orderBy: [UserOrderByWithRelationInput!], cursor: UserWhereUniqueInput, take: Int, skip: Int, distinct: [UserScalarFieldEnum!]): [User!]!
}

type UserCount {
  referrals(where: UserWhereInput): Int!
}

enum UserScalarFieldEnum {
  id
  createdAt
  updatedAt
  address
  refCodeHash
  maxReferrals
  referredById
}

type UserGroupBy {
  id: Int!
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  address: String!
  refCodeHash: String
  maxReferrals: Int!
  referredById: Int
  _count: UserCountAggregate
  _avg: UserAvgAggregate
  _sum: UserSumAggregate
  _min: UserMinAggregate
  _max: UserMaxAggregate
}

input UserOrderByWithAggregationInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  address: SortOrder
  refCodeHash: SortOrderInput
  maxReferrals: SortOrder
  referredById: SortOrderInput
  _count: UserCountOrderByAggregateInput
  _avg: UserAvgOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
}

input UserCountOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  address: SortOrder
  refCodeHash: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

input UserMaxOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  address: SortOrder
  refCodeHash: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

input UserMinOrderByAggregateInput {
  id: SortOrder
  createdAt: SortOrder
  updatedAt: SortOrder
  address: SortOrder
  refCodeHash: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

input UserSumOrderByAggregateInput {
  id: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  address: StringWithAggregatesFilter
  refCodeHash: StringNullableWithAggregatesFilter
  maxReferrals: IntWithAggregatesFilter
  referredById: IntNullableWithAggregatesFilter
}

type PnLType {
  marketId: Int!
  owner: String!
  totalDeposits: String!
  totalWithdrawals: String!
  openPositionsPnL: String!
  totalPnL: String!
  positions: [Int!]!
  positionCount: Int!
  collateralAddress: String
  collateralSymbol: String
  collateralDecimals: Int
}

type AggregatedProfitEntryType {
  owner: String!
  totalPnL: Float!
}

type ProfitRankType {
  owner: String!
  totalPnL: Float!
  rank: Int
  totalParticipants: Int!
}

type ForecasterScoreType {
  attester: String!
  numScored: Int!
  sumErrorSquared: Float!
  numTimeWeighted: Int!
  sumTimeWeightedError: Float!
  accuracyScore: Float!
}

type AccuracyRankType {
  attester: String!
  accuracyScore: Float!
  rank: Int
  totalForecasters: Int!
}

type PositionType {
  id: Int!
  chainId: Int!
  marketAddress: String!
  predictor: String!
  counterparty: String!
  predictorNftTokenId: String!
  counterpartyNftTokenId: String!
  totalCollateral: String!
  predictorCollateral: String
  counterpartyCollateral: String
  refCode: String
  status: String!
  predictorWon: Boolean
  mintedAt: Int!
  settledAt: Int
  endsAt: Int
  predictions: [PredictionType!]!
}

type PredictionType {
  conditionId: String!
  outcomeYes: Boolean!
  chainId: Int
  condition: ConditionSummary
}

type ConditionSummary {
  id: String!
  question: String
  shortName: String
  endTime: Int
  resolver: String
  settled: Boolean!
  resolvedToYes: Boolean!
}
