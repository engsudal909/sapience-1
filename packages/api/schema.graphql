# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AccuracyRankType {
  accuracyScore: Float!
  attester: String!
  rank: Int
  totalForecasters: Int!
}

type AggregateAttestation {
  _avg: AttestationAvgAggregate
  _count: AttestationCountAggregate
  _max: AttestationMaxAggregate
  _min: AttestationMinAggregate
  _sum: AttestationSumAggregate
}

type AggregateCategory {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
}

type AggregateCondition {
  _avg: ConditionAvgAggregate
  _count: ConditionCountAggregate
  _max: ConditionMaxAggregate
  _min: ConditionMinAggregate
  _sum: ConditionSumAggregate
}

type AggregateConditionGroup {
  _avg: ConditionGroupAvgAggregate
  _count: ConditionGroupCountAggregate
  _max: ConditionGroupMaxAggregate
  _min: ConditionGroupMinAggregate
  _sum: ConditionGroupSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type AggregatedProfitEntryType {
  owner: String!
  totalPnL: Float!
}

type Attestation {
  attestation_score(where: AttestationScoreWhereInput): AttestationScore
  attester: String!
  blockNumber: Int!
  comment: String
  condition: String
  createdAt: DateTimeISO!
  data: String!
  decodedDataJson: String!
  id: Int!
  marketAddress: String
  marketId: String
  prediction: String!
  questionId: String
  recipient: String!
  resolver: String
  schemaId: String!
  time: Int!
  transactionHash: String!
  uid: String!
}

type AttestationAvgAggregate {
  blockNumber: Float
  id: Float
  time: Float
}

input AttestationAvgOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  time: SortOrder
}

type AttestationCountAggregate {
  _all: Int!
  attester: Int!
  blockNumber: Int!
  comment: Int!
  condition: Int!
  createdAt: Int!
  data: Int!
  decodedDataJson: Int!
  id: Int!
  marketAddress: Int!
  marketId: Int!
  prediction: Int!
  questionId: Int!
  recipient: Int!
  resolver: Int!
  schemaId: Int!
  time: Int!
  transactionHash: Int!
  uid: Int!
}

input AttestationCountOrderByAggregateInput {
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrder
  condition: SortOrder
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  resolver: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

type AttestationGroupBy {
  _avg: AttestationAvgAggregate
  _count: AttestationCountAggregate
  _max: AttestationMaxAggregate
  _min: AttestationMinAggregate
  _sum: AttestationSumAggregate
  attester: String!
  blockNumber: Int!
  comment: String
  condition: String
  createdAt: DateTimeISO!
  data: String!
  decodedDataJson: String!
  id: Int!
  marketAddress: String
  marketId: String
  prediction: String!
  questionId: String
  recipient: String!
  resolver: String
  schemaId: String!
  time: Int!
  transactionHash: String!
  uid: String!
}

type AttestationMaxAggregate {
  attester: String
  blockNumber: Int
  comment: String
  condition: String
  createdAt: DateTimeISO
  data: String
  decodedDataJson: String
  id: Int
  marketAddress: String
  marketId: String
  prediction: String
  questionId: String
  recipient: String
  resolver: String
  schemaId: String
  time: Int
  transactionHash: String
  uid: String
}

input AttestationMaxOrderByAggregateInput {
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrder
  condition: SortOrder
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  resolver: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

type AttestationMinAggregate {
  attester: String
  blockNumber: Int
  comment: String
  condition: String
  createdAt: DateTimeISO
  data: String
  decodedDataJson: String
  id: Int
  marketAddress: String
  marketId: String
  prediction: String
  questionId: String
  recipient: String
  resolver: String
  schemaId: String
  time: Int
  transactionHash: String
  uid: String
}

input AttestationMinOrderByAggregateInput {
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrder
  condition: SortOrder
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrder
  marketId: SortOrder
  prediction: SortOrder
  questionId: SortOrder
  recipient: SortOrder
  resolver: SortOrder
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

input AttestationOrderByWithAggregationInput {
  _avg: AttestationAvgOrderByAggregateInput
  _count: AttestationCountOrderByAggregateInput
  _max: AttestationMaxOrderByAggregateInput
  _min: AttestationMinOrderByAggregateInput
  _sum: AttestationSumOrderByAggregateInput
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrderInput
  condition: SortOrderInput
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrderInput
  marketId: SortOrderInput
  prediction: SortOrder
  questionId: SortOrderInput
  recipient: SortOrder
  resolver: SortOrderInput
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

input AttestationOrderByWithRelationInput {
  attestation_score: AttestationScoreOrderByWithRelationInput
  attester: SortOrder
  blockNumber: SortOrder
  comment: SortOrderInput
  condition: SortOrderInput
  createdAt: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  id: SortOrder
  marketAddress: SortOrderInput
  marketId: SortOrderInput
  prediction: SortOrder
  questionId: SortOrderInput
  recipient: SortOrder
  resolver: SortOrderInput
  schemaId: SortOrder
  time: SortOrder
  transactionHash: SortOrder
  uid: SortOrder
}

input AttestationRelationFilter {
  is: AttestationWhereInput
  isNot: AttestationWhereInput
}

enum AttestationScalarFieldEnum {
  attester
  blockNumber
  comment
  condition
  createdAt
  data
  decodedDataJson
  id
  marketAddress
  marketId
  prediction
  questionId
  recipient
  resolver
  schemaId
  time
  transactionHash
  uid
}

input AttestationScalarWhereWithAggregatesInput {
  AND: [AttestationScalarWhereWithAggregatesInput!]
  NOT: [AttestationScalarWhereWithAggregatesInput!]
  OR: [AttestationScalarWhereWithAggregatesInput!]
  attester: StringWithAggregatesFilter
  blockNumber: IntWithAggregatesFilter
  comment: StringNullableWithAggregatesFilter
  condition: StringNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  data: StringWithAggregatesFilter
  decodedDataJson: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  marketAddress: StringNullableWithAggregatesFilter
  marketId: StringNullableWithAggregatesFilter
  prediction: StringWithAggregatesFilter
  questionId: StringNullableWithAggregatesFilter
  recipient: StringWithAggregatesFilter
  resolver: StringNullableWithAggregatesFilter
  schemaId: StringWithAggregatesFilter
  time: IntWithAggregatesFilter
  transactionHash: StringWithAggregatesFilter
  uid: StringWithAggregatesFilter
}

type AttestationScore {
  attestation: Attestation!
  attestationId: Int!
  attester: String!
  createdAt: DateTimeISO!
  errorSquared: Float
  id: Int!
  madeAt: Int!
  marketAddress: String
  marketId: String
  outcome: Int
  probabilityD18: String
  probabilityFloat: Float
  questionId: String
  resolver: String
  scoredAt: DateTimeISO
  used: Boolean!
}

input AttestationScoreNullableRelationFilter {
  is: AttestationScoreWhereInput
  isNot: AttestationScoreWhereInput
}

input AttestationScoreOrderByWithRelationInput {
  attestation: AttestationOrderByWithRelationInput
  attestationId: SortOrder
  attester: SortOrder
  createdAt: SortOrder
  errorSquared: SortOrderInput
  id: SortOrder
  madeAt: SortOrder
  marketAddress: SortOrderInput
  marketId: SortOrderInput
  outcome: SortOrderInput
  probabilityD18: SortOrderInput
  probabilityFloat: SortOrderInput
  questionId: SortOrderInput
  resolver: SortOrderInput
  scoredAt: SortOrderInput
  used: SortOrder
}

input AttestationScoreWhereInput {
  AND: [AttestationScoreWhereInput!]
  NOT: [AttestationScoreWhereInput!]
  OR: [AttestationScoreWhereInput!]
  attestation: AttestationRelationFilter
  attestationId: IntFilter
  attester: StringFilter
  createdAt: DateTimeFilter
  errorSquared: FloatNullableFilter
  id: IntFilter
  madeAt: IntFilter
  marketAddress: StringNullableFilter
  marketId: StringNullableFilter
  outcome: IntNullableFilter
  probabilityD18: StringNullableFilter
  probabilityFloat: FloatNullableFilter
  questionId: StringNullableFilter
  resolver: StringNullableFilter
  scoredAt: DateTimeNullableFilter
  used: BoolFilter
}

type AttestationSumAggregate {
  blockNumber: Int
  id: Int
  time: Int
}

input AttestationSumOrderByAggregateInput {
  blockNumber: SortOrder
  id: SortOrder
  time: SortOrder
}

input AttestationWhereInput {
  AND: [AttestationWhereInput!]
  NOT: [AttestationWhereInput!]
  OR: [AttestationWhereInput!]
  attestation_score: AttestationScoreNullableRelationFilter
  attester: StringFilter
  blockNumber: IntFilter
  comment: StringNullableFilter
  condition: StringNullableFilter
  createdAt: DateTimeFilter
  data: StringFilter
  decodedDataJson: StringFilter
  id: IntFilter
  marketAddress: StringNullableFilter
  marketId: StringNullableFilter
  prediction: StringFilter
  questionId: StringNullableFilter
  recipient: StringFilter
  resolver: StringNullableFilter
  schemaId: StringFilter
  time: IntFilter
  transactionHash: StringFilter
  uid: StringFilter
}

input AttestationWhereUniqueInput {
  AND: [AttestationWhereInput!]
  NOT: [AttestationWhereInput!]
  OR: [AttestationWhereInput!]
  attestation_score: AttestationScoreNullableRelationFilter
  attester: StringFilter
  blockNumber: IntFilter
  comment: StringNullableFilter
  condition: StringNullableFilter
  createdAt: DateTimeFilter
  data: StringFilter
  decodedDataJson: StringFilter
  id: Int
  marketAddress: StringNullableFilter
  marketId: StringNullableFilter
  prediction: StringFilter
  questionId: StringNullableFilter
  recipient: StringFilter
  resolver: StringNullableFilter
  schemaId: StringFilter
  time: IntFilter
  transactionHash: StringFilter
  uid: String
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Category {
  _count: CategoryCount
  conditionGroups(cursor: ConditionGroupWhereUniqueInput, distinct: [ConditionGroupScalarFieldEnum!], orderBy: [ConditionGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionGroupWhereInput): [ConditionGroup!]!
  conditions(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): [Condition!]!
  createdAt: DateTimeISO!
  id: Int!
  name: String!
  slug: String!
}

type CategoryAvgAggregate {
  id: Float
}

input CategoryAvgOrderByAggregateInput {
  id: SortOrder
}

type CategoryCount {
  condition(where: ConditionWhereInput): Int!
  condition_group(where: ConditionGroupWhereInput): Int!
}

type CategoryCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  slug: Int!
}

input CategoryCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type CategoryGroupBy {
  _avg: CategoryAvgAggregate
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  _sum: CategorySumAggregate
  createdAt: DateTimeISO!
  id: Int!
  name: String!
  slug: String!
}

type CategoryMaxAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input CategoryMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

type CategoryMinAggregate {
  createdAt: DateTimeISO
  id: Int
  name: String
  slug: String
}

input CategoryMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryNullableRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

input CategoryOrderByWithAggregationInput {
  _avg: CategoryAvgOrderByAggregateInput
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  _sum: CategorySumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

input CategoryOrderByWithRelationInput {
  conditionGroups: ConditionGroupOrderByRelationAggregateInput
  conditions: ConditionOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
}

enum CategoryScalarFieldEnum {
  createdAt
  id
  name
  slug
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  slug: StringWithAggregatesFilter
}

type CategorySumAggregate {
  id: Int
}

input CategorySumOrderByAggregateInput {
  id: SortOrder
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  conditionGroups: ConditionGroupListRelationFilter
  conditions: ConditionListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  slug: StringFilter
}

input CategoryWhereUniqueInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  conditionGroups: ConditionGroupListRelationFilter
  conditions: ConditionListRelationFilter
  createdAt: DateTimeFilter
  id: Int
  name: String
  slug: String
}

type Condition {
  _count: ConditionCount
  assertionId: String
  assertionTimestamp: Int
  category(where: CategoryWhereInput): Category
  categoryId: Int
  chainId: Int!
  claimStatement: String!
  conditionGroup(where: ConditionGroupWhereInput): ConditionGroup
  conditionGroupId: Int
  createdAt: DateTimeISO!
  description: String!
  displayOrder: Int
  endTime: Int!
  id: String!
  openInterest: String!
  predictions(cursor: PredictionWhereUniqueInput, distinct: [PredictionScalarFieldEnum!], orderBy: [PredictionOrderByWithRelationInput!], skip: Int, take: Int, where: PredictionWhereInput): [Prediction!]!
  public: Boolean!
  question: String!
  resolvedToYes: Boolean!
  settled: Boolean!
  settledAt: Int
  shortName: String
  similarMarkets: [String!]!
}

type ConditionAvgAggregate {
  assertionTimestamp: Float
  categoryId: Float
  chainId: Float
  conditionGroupId: Float
  displayOrder: Float
  endTime: Float
  settledAt: Float
}

input ConditionAvgOrderByAggregateInput {
  assertionTimestamp: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  conditionGroupId: SortOrder
  displayOrder: SortOrder
  endTime: SortOrder
  settledAt: SortOrder
}

type ConditionCount {
  predictions(where: PredictionWhereInput): Int!
}

type ConditionCountAggregate {
  _all: Int!
  assertionId: Int!
  assertionTimestamp: Int!
  categoryId: Int!
  chainId: Int!
  claimStatement: Int!
  conditionGroupId: Int!
  createdAt: Int!
  description: Int!
  displayOrder: Int!
  endTime: Int!
  id: Int!
  openInterest: Int!
  public: Int!
  question: Int!
  resolvedToYes: Int!
  settled: Int!
  settledAt: Int!
  shortName: Int!
  similarMarkets: Int!
}

input ConditionCountOrderByAggregateInput {
  assertionId: SortOrder
  assertionTimestamp: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  claimStatement: SortOrder
  conditionGroupId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  displayOrder: SortOrder
  endTime: SortOrder
  id: SortOrder
  openInterest: SortOrder
  public: SortOrder
  question: SortOrder
  resolvedToYes: SortOrder
  settled: SortOrder
  settledAt: SortOrder
  shortName: SortOrder
  similarMarkets: SortOrder
}

type ConditionGroup {
  _count: ConditionGroupCount
  category(where: CategoryWhereInput): Category
  categoryId: Int
  conditions(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): [Condition!]!
  createdAt: DateTimeISO!
  id: Int!
  name: String!
}

type ConditionGroupAvgAggregate {
  categoryId: Float
  id: Float
}

input ConditionGroupAvgOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

type ConditionGroupBy {
  _avg: ConditionAvgAggregate
  _count: ConditionCountAggregate
  _max: ConditionMaxAggregate
  _min: ConditionMinAggregate
  _sum: ConditionSumAggregate
  assertionId: String
  assertionTimestamp: Int
  categoryId: Int
  chainId: Int!
  claimStatement: String!
  conditionGroupId: Int
  createdAt: DateTimeISO!
  description: String!
  displayOrder: Int
  endTime: Int!
  id: String!
  openInterest: String!
  public: Boolean!
  question: String!
  resolvedToYes: Boolean!
  settled: Boolean!
  settledAt: Int
  shortName: String
  similarMarkets: [String!]
}

type ConditionGroupCount {
  condition(where: ConditionWhereInput): Int!
}

type ConditionGroupCountAggregate {
  _all: Int!
  categoryId: Int!
  createdAt: Int!
  id: Int!
  name: Int!
}

input ConditionGroupCountOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
}

type ConditionGroupGroupBy {
  _avg: ConditionGroupAvgAggregate
  _count: ConditionGroupCountAggregate
  _max: ConditionGroupMaxAggregate
  _min: ConditionGroupMinAggregate
  _sum: ConditionGroupSumAggregate
  categoryId: Int
  createdAt: DateTimeISO!
  id: Int!
  name: String!
}

input ConditionGroupListRelationFilter {
  every: ConditionGroupWhereInput
  none: ConditionGroupWhereInput
  some: ConditionGroupWhereInput
}

type ConditionGroupMaxAggregate {
  categoryId: Int
  createdAt: DateTimeISO
  id: Int
  name: String
}

input ConditionGroupMaxOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
}

type ConditionGroupMinAggregate {
  categoryId: Int
  createdAt: DateTimeISO
  id: Int
  name: String
}

input ConditionGroupMinOrderByAggregateInput {
  categoryId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
}

input ConditionGroupNullableRelationFilter {
  is: ConditionGroupWhereInput
  isNot: ConditionGroupWhereInput
}

input ConditionGroupOrderByRelationAggregateInput {
  _count: SortOrder
}

input ConditionGroupOrderByWithAggregationInput {
  _avg: ConditionGroupAvgOrderByAggregateInput
  _count: ConditionGroupCountOrderByAggregateInput
  _max: ConditionGroupMaxOrderByAggregateInput
  _min: ConditionGroupMinOrderByAggregateInput
  _sum: ConditionGroupSumOrderByAggregateInput
  categoryId: SortOrderInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
}

input ConditionGroupOrderByWithRelationInput {
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrderInput
  conditions: ConditionOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
}

enum ConditionGroupScalarFieldEnum {
  categoryId
  createdAt
  id
  name
}

input ConditionGroupScalarWhereWithAggregatesInput {
  AND: [ConditionGroupScalarWhereWithAggregatesInput!]
  NOT: [ConditionGroupScalarWhereWithAggregatesInput!]
  OR: [ConditionGroupScalarWhereWithAggregatesInput!]
  categoryId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type ConditionGroupSumAggregate {
  categoryId: Int
  id: Int
}

input ConditionGroupSumOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
}

input ConditionGroupWhereInput {
  AND: [ConditionGroupWhereInput!]
  NOT: [ConditionGroupWhereInput!]
  OR: [ConditionGroupWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  conditions: ConditionListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
}

input ConditionGroupWhereUniqueInput {
  AND: [ConditionGroupWhereInput!]
  NOT: [ConditionGroupWhereInput!]
  OR: [ConditionGroupWhereInput!]
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  conditions: ConditionListRelationFilter
  createdAt: DateTimeFilter
  id: Int
  name: String
}

input ConditionListRelationFilter {
  every: ConditionWhereInput
  none: ConditionWhereInput
  some: ConditionWhereInput
}

type ConditionMaxAggregate {
  assertionId: String
  assertionTimestamp: Int
  categoryId: Int
  chainId: Int
  claimStatement: String
  conditionGroupId: Int
  createdAt: DateTimeISO
  description: String
  displayOrder: Int
  endTime: Int
  id: String
  openInterest: String
  public: Boolean
  question: String
  resolvedToYes: Boolean
  settled: Boolean
  settledAt: Int
  shortName: String
}

input ConditionMaxOrderByAggregateInput {
  assertionId: SortOrder
  assertionTimestamp: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  claimStatement: SortOrder
  conditionGroupId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  displayOrder: SortOrder
  endTime: SortOrder
  id: SortOrder
  openInterest: SortOrder
  public: SortOrder
  question: SortOrder
  resolvedToYes: SortOrder
  settled: SortOrder
  settledAt: SortOrder
  shortName: SortOrder
}

type ConditionMinAggregate {
  assertionId: String
  assertionTimestamp: Int
  categoryId: Int
  chainId: Int
  claimStatement: String
  conditionGroupId: Int
  createdAt: DateTimeISO
  description: String
  displayOrder: Int
  endTime: Int
  id: String
  openInterest: String
  public: Boolean
  question: String
  resolvedToYes: Boolean
  settled: Boolean
  settledAt: Int
  shortName: String
}

input ConditionMinOrderByAggregateInput {
  assertionId: SortOrder
  assertionTimestamp: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  claimStatement: SortOrder
  conditionGroupId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  displayOrder: SortOrder
  endTime: SortOrder
  id: SortOrder
  openInterest: SortOrder
  public: SortOrder
  question: SortOrder
  resolvedToYes: SortOrder
  settled: SortOrder
  settledAt: SortOrder
  shortName: SortOrder
}

input ConditionOrderByRelationAggregateInput {
  _count: SortOrder
}

input ConditionOrderByWithAggregationInput {
  _avg: ConditionAvgOrderByAggregateInput
  _count: ConditionCountOrderByAggregateInput
  _max: ConditionMaxOrderByAggregateInput
  _min: ConditionMinOrderByAggregateInput
  _sum: ConditionSumOrderByAggregateInput
  assertionId: SortOrderInput
  assertionTimestamp: SortOrderInput
  categoryId: SortOrderInput
  chainId: SortOrder
  claimStatement: SortOrder
  conditionGroupId: SortOrderInput
  createdAt: SortOrder
  description: SortOrder
  displayOrder: SortOrderInput
  endTime: SortOrder
  id: SortOrder
  openInterest: SortOrder
  public: SortOrder
  question: SortOrder
  resolvedToYes: SortOrder
  settled: SortOrder
  settledAt: SortOrderInput
  shortName: SortOrderInput
  similarMarkets: SortOrder
}

input ConditionOrderByWithRelationInput {
  assertionId: SortOrderInput
  assertionTimestamp: SortOrderInput
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrderInput
  chainId: SortOrder
  claimStatement: SortOrder
  conditionGroup: ConditionGroupOrderByWithRelationInput
  conditionGroupId: SortOrderInput
  createdAt: SortOrder
  description: SortOrder
  displayOrder: SortOrderInput
  endTime: SortOrder
  id: SortOrder
  openInterest: SortOrder
  predictions: PredictionOrderByRelationAggregateInput
  public: SortOrder
  question: SortOrder
  resolvedToYes: SortOrder
  settled: SortOrder
  settledAt: SortOrderInput
  shortName: SortOrderInput
  similarMarkets: SortOrder
}

input ConditionRelationFilter {
  is: ConditionWhereInput
  isNot: ConditionWhereInput
}

enum ConditionScalarFieldEnum {
  assertionId
  assertionTimestamp
  categoryId
  chainId
  claimStatement
  conditionGroupId
  createdAt
  description
  displayOrder
  endTime
  id
  openInterest
  public
  question
  resolvedToYes
  settled
  settledAt
  shortName
  similarMarkets
}

input ConditionScalarWhereWithAggregatesInput {
  AND: [ConditionScalarWhereWithAggregatesInput!]
  NOT: [ConditionScalarWhereWithAggregatesInput!]
  OR: [ConditionScalarWhereWithAggregatesInput!]
  assertionId: StringNullableWithAggregatesFilter
  assertionTimestamp: IntNullableWithAggregatesFilter
  categoryId: IntNullableWithAggregatesFilter
  chainId: IntWithAggregatesFilter
  claimStatement: StringWithAggregatesFilter
  conditionGroupId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  displayOrder: IntNullableWithAggregatesFilter
  endTime: IntWithAggregatesFilter
  id: StringWithAggregatesFilter
  openInterest: StringWithAggregatesFilter
  public: BoolWithAggregatesFilter
  question: StringWithAggregatesFilter
  resolvedToYes: BoolWithAggregatesFilter
  settled: BoolWithAggregatesFilter
  settledAt: IntNullableWithAggregatesFilter
  shortName: StringNullableWithAggregatesFilter
  similarMarkets: StringNullableListFilter
}

type ConditionSumAggregate {
  assertionTimestamp: Int
  categoryId: Int
  chainId: Int
  conditionGroupId: Int
  displayOrder: Int
  endTime: Int
  settledAt: Int
}

input ConditionSumOrderByAggregateInput {
  assertionTimestamp: SortOrder
  categoryId: SortOrder
  chainId: SortOrder
  conditionGroupId: SortOrder
  displayOrder: SortOrder
  endTime: SortOrder
  settledAt: SortOrder
}

type ConditionSummary {
  endTime: Int
  id: String!
  question: String
  shortName: String
}

input ConditionWhereInput {
  AND: [ConditionWhereInput!]
  NOT: [ConditionWhereInput!]
  OR: [ConditionWhereInput!]
  assertionId: StringNullableFilter
  assertionTimestamp: IntNullableFilter
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  claimStatement: StringFilter
  conditionGroup: ConditionGroupNullableRelationFilter
  conditionGroupId: IntNullableFilter
  createdAt: DateTimeFilter
  description: StringFilter
  displayOrder: IntNullableFilter
  endTime: IntFilter
  id: StringFilter
  openInterest: StringFilter
  predictions: PredictionListRelationFilter
  public: BoolFilter
  question: StringFilter
  resolvedToYes: BoolFilter
  settled: BoolFilter
  settledAt: IntNullableFilter
  shortName: StringNullableFilter
  similarMarkets: StringNullableListFilter
}

input ConditionWhereUniqueInput {
  AND: [ConditionWhereInput!]
  NOT: [ConditionWhereInput!]
  OR: [ConditionWhereInput!]
  assertionId: StringNullableFilter
  assertionTimestamp: IntNullableFilter
  category: CategoryNullableRelationFilter
  categoryId: IntNullableFilter
  chainId: IntFilter
  claimStatement: StringFilter
  conditionGroup: ConditionGroupNullableRelationFilter
  conditionGroupId: IntNullableFilter
  createdAt: DateTimeFilter
  description: StringFilter
  displayOrder: IntNullableFilter
  endTime: IntFilter
  id: String
  openInterest: StringFilter
  predictions: PredictionListRelationFilter
  public: BoolFilter
  question: StringFilter
  resolvedToYes: BoolFilter
  settled: BoolFilter
  settledAt: IntNullableFilter
  shortName: StringNullableFilter
  similarMarkets: StringNullableListFilter
}

input DateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

input DateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input EnumLimitOrderStatusFilter {
  equals: LimitOrderStatus
  in: [LimitOrderStatus!]
  not: NestedEnumLimitOrderStatusFilter
  notIn: [LimitOrderStatus!]
}

input EnumPositionStatusFilter {
  equals: PositionStatus
  in: [PositionStatus!]
  not: NestedEnumPositionStatusFilter
  notIn: [PositionStatus!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

type ForecasterScoreType {
  accuracyScore: Float!
  attester: String!
  numScored: Int!
  numTimeWeighted: Int!
  sumErrorSquared: Float!
  sumTimeWeightedError: Float!
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type LimitOrder {
  _count: LimitOrderCount
  cancelledAt: Int
  cancelledTxHash: String
  chainId: Int!
  counterparty: String
  counterpartyCollateral: String!
  createdAt: DateTimeISO!
  filledAt: Int
  filledTxHash: String
  id: Int!
  marketAddress: String!
  orderId: String!
  placedAt: Int!
  placedTxHash: String!
  predictions(cursor: PredictionWhereUniqueInput, distinct: [PredictionScalarFieldEnum!], orderBy: [PredictionOrderByWithRelationInput!], skip: Int, take: Int, where: PredictionWhereInput): [Prediction!]!
  predictor: String!
  predictorCollateral: String!
  refCode: String
  resolver: String!
  status: LimitOrderStatus!
}

type LimitOrderCount {
  predictions(where: PredictionWhereInput): Int!
}

input LimitOrderNullableRelationFilter {
  is: LimitOrderWhereInput
  isNot: LimitOrderWhereInput
}

input LimitOrderOrderByWithRelationInput {
  cancelledAt: SortOrderInput
  cancelledTxHash: SortOrderInput
  chainId: SortOrder
  counterparty: SortOrderInput
  counterpartyCollateral: SortOrder
  createdAt: SortOrder
  filledAt: SortOrderInput
  filledTxHash: SortOrderInput
  id: SortOrder
  marketAddress: SortOrder
  orderId: SortOrder
  placedAt: SortOrder
  placedTxHash: SortOrder
  predictions: PredictionOrderByRelationAggregateInput
  predictor: SortOrder
  predictorCollateral: SortOrder
  refCode: SortOrderInput
  resolver: SortOrder
  status: SortOrder
}

enum LimitOrderStatus {
  cancelled
  filled
  pending
}

input LimitOrderWhereInput {
  AND: [LimitOrderWhereInput!]
  NOT: [LimitOrderWhereInput!]
  OR: [LimitOrderWhereInput!]
  cancelledAt: IntNullableFilter
  cancelledTxHash: StringNullableFilter
  chainId: IntFilter
  counterparty: StringNullableFilter
  counterpartyCollateral: StringFilter
  createdAt: DateTimeFilter
  filledAt: IntNullableFilter
  filledTxHash: StringNullableFilter
  id: IntFilter
  marketAddress: StringFilter
  orderId: StringFilter
  placedAt: IntFilter
  placedTxHash: StringFilter
  predictions: PredictionListRelationFilter
  predictor: StringFilter
  predictorCollateral: StringFilter
  refCode: StringNullableFilter
  resolver: StringFilter
  status: EnumLimitOrderStatusFilter
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolNullableFilter {
  equals: Boolean
  not: NestedBoolNullableFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeNullableFilter {
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeNullableFilter
  notIn: [DateTimeISO!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTimeISO
  gt: DateTimeISO
  gte: DateTimeISO
  in: [DateTimeISO!]
  lt: DateTimeISO
  lte: DateTimeISO
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTimeISO!]
}

input NestedEnumLimitOrderStatusFilter {
  equals: LimitOrderStatus
  in: [LimitOrderStatus!]
  not: NestedEnumLimitOrderStatusFilter
  notIn: [LimitOrderStatus!]
}

input NestedEnumPositionStatusFilter {
  equals: PositionStatus
  in: [PositionStatus!]
  not: NestedEnumPositionStatusFilter
  notIn: [PositionStatus!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

type PnLType {
  collateralAddress: String
  collateralDecimals: Int
  collateralSymbol: String
  marketId: Int!
  openPositionsPnL: String!
  owner: String!
  positionCount: Int!
  positions: [Int!]!
  totalDeposits: String!
  totalPnL: String!
  totalWithdrawals: String!
}

"""Position model to store on-chain prediction positions"""
type Position {
  _count: PositionCount
  chainId: Int!
  counterparty: String!
  counterpartyCollateral: String
  counterpartyNftTokenId: String!
  createdAt: DateTimeISO!
  endsAt: Int
  id: Int!
  marketAddress: String!
  mintedAt: Int!
  predictions(cursor: PredictionWhereUniqueInput, distinct: [PredictionScalarFieldEnum!], orderBy: [PredictionOrderByWithRelationInput!], skip: Int, take: Int, where: PredictionWhereInput): [Prediction!]!
  predictor: String!
  predictorCollateral: String
  predictorNftTokenId: String!

  """
  True when the predictor's submitted outcomes were correct (previously makerWon)
  """
  predictorWon: Boolean
  refCode: String
  settledAt: Int
  status: PositionStatus!
  totalCollateral: String!
}

type PositionCount {
  predictions(where: PredictionWhereInput): Int!
}

input PositionNullableRelationFilter {
  is: PositionWhereInput
  isNot: PositionWhereInput
}

input PositionOrderByWithRelationInput {
  chainId: SortOrder
  counterparty: SortOrder
  counterpartyCollateral: SortOrderInput
  counterpartyNftTokenId: SortOrder
  createdAt: SortOrder
  endsAt: SortOrderInput
  id: SortOrder
  marketAddress: SortOrder
  mintedAt: SortOrder
  predictions: PredictionOrderByRelationAggregateInput
  predictor: SortOrder
  predictorCollateral: SortOrderInput
  predictorNftTokenId: SortOrder
  predictorWon: SortOrderInput
  refCode: SortOrderInput
  settledAt: SortOrderInput
  status: SortOrder
  totalCollateral: SortOrder
}

enum PositionStatus {
  active
  consolidated
  settled
}

type PositionType {
  chainId: Int!
  counterparty: String!
  counterpartyCollateral: String
  counterpartyNftTokenId: String!
  endsAt: Int
  id: Int!
  marketAddress: String!
  mintedAt: Int!
  predictions: [PredictionType!]!
  predictor: String!
  predictorCollateral: String
  predictorNftTokenId: String!
  predictorWon: Boolean
  refCode: String
  settledAt: Int
  status: String!
  totalCollateral: String!
}

input PositionWhereInput {
  AND: [PositionWhereInput!]
  NOT: [PositionWhereInput!]
  OR: [PositionWhereInput!]
  chainId: IntFilter
  counterparty: StringFilter
  counterpartyCollateral: StringNullableFilter
  counterpartyNftTokenId: StringFilter
  createdAt: DateTimeFilter
  endsAt: IntNullableFilter
  id: IntFilter
  marketAddress: StringFilter
  mintedAt: IntFilter
  predictions: PredictionListRelationFilter
  predictor: StringFilter
  predictorCollateral: StringNullableFilter
  predictorNftTokenId: StringFilter
  predictorWon: BoolNullableFilter
  refCode: StringNullableFilter
  settledAt: IntNullableFilter
  status: EnumPositionStatusFilter
  totalCollateral: StringFilter
}

type Prediction {
  chainId: Int
  condition: Condition!
  conditionId: String!
  createdAt: DateTimeISO!
  id: Int!
  limitOrder(where: LimitOrderWhereInput): LimitOrder
  limitOrderId: Int
  outcomeYes: Boolean!
  position(where: PositionWhereInput): Position
  positionId: Int
  resolver: String!
}

input PredictionListRelationFilter {
  every: PredictionWhereInput
  none: PredictionWhereInput
  some: PredictionWhereInput
}

input PredictionOrderByRelationAggregateInput {
  _count: SortOrder
}

input PredictionOrderByWithRelationInput {
  chainId: SortOrderInput
  condition: ConditionOrderByWithRelationInput
  conditionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  limitOrder: LimitOrderOrderByWithRelationInput
  limitOrderId: SortOrderInput
  outcomeYes: SortOrder
  position: PositionOrderByWithRelationInput
  positionId: SortOrderInput
  resolver: SortOrder
}

input PredictionPositionIdConditionIdResolverCompoundUniqueInput {
  conditionId: String!
  positionId: Int!
  resolver: String!
}

enum PredictionScalarFieldEnum {
  chainId
  conditionId
  createdAt
  id
  limitOrderId
  outcomeYes
  positionId
  resolver
}

type PredictionType {
  chainId: Int
  condition: ConditionSummary
  conditionId: String!
  outcomeYes: Boolean!
  resolver: String!
}

input PredictionWhereInput {
  AND: [PredictionWhereInput!]
  NOT: [PredictionWhereInput!]
  OR: [PredictionWhereInput!]
  chainId: IntNullableFilter
  condition: ConditionRelationFilter
  conditionId: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  limitOrder: LimitOrderNullableRelationFilter
  limitOrderId: IntNullableFilter
  outcomeYes: BoolFilter
  position: PositionNullableRelationFilter
  positionId: IntNullableFilter
  resolver: StringFilter
}

input PredictionWhereUniqueInput {
  AND: [PredictionWhereInput!]
  NOT: [PredictionWhereInput!]
  OR: [PredictionWhereInput!]
  chainId: IntNullableFilter
  condition: ConditionRelationFilter
  conditionId: StringFilter
  createdAt: DateTimeFilter
  id: Int
  limitOrder: LimitOrderNullableRelationFilter
  limitOrderId: IntNullableFilter
  outcomeYes: BoolFilter
  position: PositionNullableRelationFilter
  positionId: IntNullableFilter
  positionId_conditionId_resolver: PredictionPositionIdConditionIdResolverCompoundUniqueInput
  resolver: StringFilter
}

type ProfitRankType {
  owner: String!
  rank: Int
  totalParticipants: Int!
  totalPnL: Float!
}

type Query {
  accuracyRankByAddress(attester: String!): AccuracyRankType!
  aggregateAttestation(cursor: AttestationWhereUniqueInput, orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): AggregateAttestation!
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateCondition(cursor: ConditionWhereUniqueInput, orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): AggregateCondition!
  aggregateConditionGroup(cursor: ConditionGroupWhereUniqueInput, orderBy: [ConditionGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionGroupWhereInput): AggregateConditionGroup!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  allTimeProfitLeaderboard: [AggregatedProfitEntryType!]!
  attestation(where: AttestationWhereUniqueInput!): Attestation
  attestations(cursor: AttestationWhereUniqueInput, distinct: [AttestationScalarFieldEnum!], orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): [Attestation!]!
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  condition(where: ConditionWhereUniqueInput!): Condition
  conditionGroup(where: ConditionGroupWhereUniqueInput!): ConditionGroup
  conditionGroups(cursor: ConditionGroupWhereUniqueInput, distinct: [ConditionGroupScalarFieldEnum!], orderBy: [ConditionGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionGroupWhereInput): [ConditionGroup!]!
  conditions(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): [Condition!]!
  findFirstAttestation(cursor: AttestationWhereUniqueInput, distinct: [AttestationScalarFieldEnum!], orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): Attestation
  findFirstAttestationOrThrow(cursor: AttestationWhereUniqueInput, distinct: [AttestationScalarFieldEnum!], orderBy: [AttestationOrderByWithRelationInput!], skip: Int, take: Int, where: AttestationWhereInput): Attestation
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCategoryOrThrow(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCondition(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): Condition
  findFirstConditionGroup(cursor: ConditionGroupWhereUniqueInput, distinct: [ConditionGroupScalarFieldEnum!], orderBy: [ConditionGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionGroupWhereInput): ConditionGroup
  findFirstConditionGroupOrThrow(cursor: ConditionGroupWhereUniqueInput, distinct: [ConditionGroupScalarFieldEnum!], orderBy: [ConditionGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionGroupWhereInput): ConditionGroup
  findFirstConditionOrThrow(cursor: ConditionWhereUniqueInput, distinct: [ConditionScalarFieldEnum!], orderBy: [ConditionOrderByWithRelationInput!], skip: Int, take: Int, where: ConditionWhereInput): Condition
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  forecasterScore(attester: String!): ForecasterScoreType
  getAttestation(where: AttestationWhereUniqueInput!): Attestation
  getCategory(where: CategoryWhereUniqueInput!): Category
  getCondition(where: ConditionWhereUniqueInput!): Condition
  getConditionGroup(where: ConditionGroupWhereUniqueInput!): ConditionGroup
  getLeaderboard(chainId: Int!, marketAddress: String!): [PnLType!]!
  getUser(where: UserWhereUniqueInput!): User
  groupByAttestation(by: [AttestationScalarFieldEnum!]!, having: AttestationScalarWhereWithAggregatesInput, orderBy: [AttestationOrderByWithAggregationInput!], skip: Int, take: Int, where: AttestationWhereInput): [AttestationGroupBy!]!
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByCondition(by: [ConditionScalarFieldEnum!]!, having: ConditionScalarWhereWithAggregatesInput, orderBy: [ConditionOrderByWithAggregationInput!], skip: Int, take: Int, where: ConditionWhereInput): [ConditionGroupBy!]!
  groupByConditionGroup(by: [ConditionGroupScalarFieldEnum!]!, having: ConditionGroupScalarWhereWithAggregatesInput, orderBy: [ConditionGroupOrderByWithAggregationInput!], skip: Int, take: Int, where: ConditionGroupWhereInput): [ConditionGroupGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  positions(address: String!, chainId: Int, orderBy: String, orderDirection: String, skip: Int! = 0, take: Int! = 50): [PositionType!]!
  positionsByConditionId(chainId: Int, conditionId: String!, skip: Int! = 0, take: Int! = 100): [PositionType!]!
  positionsCount(address: String!, chainId: Int): Int!
  profitRankByAddress(owner: String!): ProfitRankType!
  topForecasters(limit: Int! = 10): [ForecasterScoreType!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

"""
Application-level user record, keyed by wallet address,
used for referrals and other per-wallet metadata.
"""
type User {
  _count: UserCount

  """Canonical Ethereum wallet address for this user."""
  address: String!
  createdAt: DateTimeISO!
  id: Int!

  """
  Maximum number of referrals this user's code allows. Default is 0,
  so codes are not usable until explicitly configured.
  """
  maxReferrals: Int!

  """keccak256(utf8(trimmed_lowercase_code)) stored as 0x-prefixed hex."""
  refCodeHash: String
  referrals(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
  referredBy(where: UserWhereInput): User
  referredById: Int
  updatedAt: DateTimeISO!
}

type UserAvgAggregate {
  id: Float
  maxReferrals: Float
  referredById: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

type UserCount {
  referrals(where: UserWhereInput): Int!
}

type UserCountAggregate {
  _all: Int!
  address: Int!
  createdAt: Int!
  id: Int!
  maxReferrals: Int!
  refCodeHash: Int!
  referredById: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrder
  referredById: SortOrder
  updatedAt: SortOrder
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  address: String!
  createdAt: DateTimeISO!
  id: Int!
  maxReferrals: Int!
  refCodeHash: String
  referredById: Int
  updatedAt: DateTimeISO!
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

type UserMaxAggregate {
  address: String
  createdAt: DateTimeISO
  id: Int
  maxReferrals: Int
  refCodeHash: String
  referredById: Int
  updatedAt: DateTimeISO
}

input UserMaxOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrder
  referredById: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  address: String
  createdAt: DateTimeISO
  id: Int
  maxReferrals: Int
  refCodeHash: String
  referredById: Int
  updatedAt: DateTimeISO
}

input UserMinOrderByAggregateInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrder
  referredById: SortOrder
  updatedAt: SortOrder
}

input UserNullableRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrderInput
  referredById: SortOrderInput
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  address: SortOrder
  createdAt: SortOrder
  id: SortOrder
  maxReferrals: SortOrder
  refCodeHash: SortOrderInput
  referrals: UserOrderByRelationAggregateInput
  referredBy: UserOrderByWithRelationInput
  referredById: SortOrderInput
  updatedAt: SortOrder
}

enum UserScalarFieldEnum {
  address
  createdAt
  id
  maxReferrals
  refCodeHash
  referredById
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  address: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  maxReferrals: IntWithAggregatesFilter
  refCodeHash: StringNullableWithAggregatesFilter
  referredById: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
  maxReferrals: Int
  referredById: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
  maxReferrals: SortOrder
  referredById: SortOrder
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  maxReferrals: IntFilter
  refCodeHash: StringNullableFilter
  referrals: UserListRelationFilter
  referredBy: UserNullableRelationFilter
  referredById: IntNullableFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  address: String
  createdAt: DateTimeFilter
  id: Int
  maxReferrals: IntFilter
  refCodeHash: String
  referrals: UserListRelationFilter
  referredBy: UserNullableRelationFilter
  referredById: IntNullableFilter
  updatedAt: DateTimeFilter
}