generator client {
  provider      = "prisma-client-js"
  output        = "../generated/prisma"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

generator typegraphql {
  provider = "typegraphql-prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Category {
  id           Int            @id(map: "PK_9c4e4a89e3674fc9f382d733f03") @default(autoincrement())
  createdAt    DateTime       @default(now()) @db.Timestamp(6)
  name         String         @unique(map: "UQ_23c05c292c439d77b0de816b500") @db.VarChar
  slug         String         @unique(map: "UQ_cb73208f151aa71cdd78f662d70") @db.VarChar
  /// @TypeGraphQL.field(name: "conditions")
  condition    Condition[]

  @@index([slug], map: "IDX_cb73208f151aa71cdd78f662d7")
  @@map("category")
}

model Event {
  id              Int           @id(map: "PK_30c2f3bbaf6d34a55f8ae6e4614") @default(autoincrement())
  createdAt       DateTime      @default(now()) @db.Timestamp(6)
  blockNumber     Int
  transactionHash String        @db.VarChar
  timestamp       BigInt
  logIndex        Int
  logData         Json          @db.Json

  @@index([timestamp], map: "IDX_2c15918ff289396205521c5f3c")
  @@index([blockNumber], map: "IDX_5430e2d7fe1df2bcada2c12deb")
  @@map("event")
}

model KeyValueStore {
  key       String   @id @db.VarChar(255)
  value     String   @db.Text
  createdAt DateTime @default(now()) @db.Timestamp(6)
  updatedAt DateTime @updatedAt @db.Timestamp(6)

  @@map("key_value_store")
}

model Migrations {
  id        Int    @id(map: "PK_8c82d7f526340ab734260ea46be") @default(autoincrement())
  timestamp BigInt
  name      String @db.VarChar

  @@map("migrations")
}

model RenderJob {
  id        Int      @id(map: "PK_a00488019eafb11b27af1aa1a76") @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)
  jobId     String   @db.VarChar
  serviceId String   @db.VarChar

  @@map("render_job")
}

model Attestation {
  id              Int      @id(map: "PK_attestation") @default(autoincrement())
  createdAt       DateTime @default(now()) @db.Timestamp(6)
  
  // Core EAS fields
  uid             String   @unique @db.VarChar
  attester        String   @db.VarChar
  recipient       String   @db.VarChar
  time            Int // Using time instead of timestamp to mimic AES indexer
  blockNumber     Int
  transactionHash String   @db.VarChar
  schemaId        String   @db.VarChar

  // Prediction market raw data
  data            String   @db.VarChar    
  decodedDataJson String   @db.VarChar @default("")

  // Prediction market schema data
  marketAddress   String   @db.VarChar
  marketId        String   @db.VarChar
  questionId      String   @db.VarChar
  prediction      String   @db.VarChar
  comment         String?  @db.Text

  // Relation to scores
  attestation_score AttestationScore?

  @@unique([uid], map: "UQ_attestation_uid")
  @@index([attester], map: "IDX_attestation_attester")
  @@index([recipient], map: "IDX_attestation_recipient")
  @@index([time], map: "IDX_attestation_time")
  @@index([marketAddress], map: "IDX_attestation_market_address")
  @@index([marketId], map: "IDX_attestation_market_id")
  @@index([questionId], map: "IDX_attestation_question_id")
  @@map("attestation")
}

model AttestationScore {
  id               Int         @id @default(autoincrement())
  createdAt        DateTime    @default(now()) @db.Timestamp(6)

  // Foreign keys and identifiers
  attestationId    Int         @unique
  attestation      Attestation @relation(fields: [attestationId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  attester         String      @db.VarChar
  marketAddress    String      @db.VarChar
  marketId         String      @db.VarChar
  questionId       String?     @db.VarChar

  // Forecast metadata
  madeAt           Int
  used             Boolean     @default(false)

  // Probability and scoring
  probabilityD18   String?     @db.VarChar
  probabilityFloat Float?
  outcome          Int?
  errorSquared     Float?
  scoredAt         DateTime?   @db.Timestamp(6)

  @@index([attester], map: "IDX_attestation_score_attester")
  @@index([marketAddress], map: "IDX_attestation_score_market_address")
  @@index([marketId], map: "IDX_attestation_score_market_id")
  @@index([attester, marketAddress, marketId], map: "IDX_attestation_score_attester_market")
  @@index([attester, marketAddress, marketId, madeAt], map: "IDX_attestation_score_attester_market_madeat")
  @@map("attestation_score")
}

/// Precomputed horizon-weighted error per (attester, market)
model AttesterMarketTwError {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now()) @db.Timestamp(6)
  attester      String   @db.VarChar
  marketAddress String   @db.VarChar
  marketId      Int
  twError       Float
  computedAt    DateTime @updatedAt @db.Timestamp(6)

  @@unique([attester, marketAddress, marketId], map: "UQ_attester_market_tw_error")
  @@index([attester], map: "IDX_attester_market_tw_error_attester")
  @@index([marketAddress, marketId], map: "IDX_attester_market_tw_error_market")
  @@map("attester_market_tw_error")
}

/// Chat message history for ephemeral chat websocket
model ChatMessage {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now()) @db.Timestamp(6)
  text      String   @db.Text
  address   String?  @db.VarChar
  timestamp BigInt   @db.BigInt

  @@index([timestamp], map: "IDX_chat_message_timestamp")
  @@index([address], map: "IDX_chat_message_address")
  @@map("chat_message")
}

model Condition {
  id             String    @id @db.VarChar
  createdAt      DateTime  @default(now()) @db.Timestamp(6)
  question       String    @db.VarChar
  shortName      String?   @db.VarChar
  categoryId     Int?
  category       Category? @relation(fields: [categoryId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  endTime        Int
  public         Boolean   @default(true)
  claimStatement String    @db.VarChar
  description    String    @db.Text
  similarMarkets String[]  @default([])
  chainId        Int       @default(42161)
  openInterest   String    @default("0") @db.VarChar
  
  // Resolution status
  settled        Boolean   @default(false)
  resolvedToYes  Boolean   @default(false)
  settledAt      Int?
  assertionId    String?   @db.VarChar
  assertionTimestamp Int?

  @@index([categoryId])
  @@index([endTime])
  @@map("condition")
}

/// Position model to store on-chain prediction positions
model Position {
  id               Int       @id @default(autoincrement())
  createdAt        DateTime  @default(now()) @db.Timestamp(6)

  // On-chain identifiers
  chainId          Int
  marketAddress    String    @db.VarChar
  maker            String    @db.VarChar
  taker            String    @db.VarChar
  makerNftTokenId  String    @db.VarChar
  takerNftTokenId  String    @db.VarChar
  totalCollateral  String    @db.VarChar
  makerCollateral  String?   @db.VarChar
  takerCollateral  String?   @db.VarChar
  refCode          String?   @db.VarChar

  // Status
  status           PositionStatus @default(active)
  makerWon         Boolean?
  mintedAt         Int
  settledAt        Int?

  // Derived for UI convenience
  endsAt           Int?

  // Raw predictions as emitted/encoded on-chain
  // Example JSON: [{ conditionId: "0x...", prediction: true }]
  predictions Json      @db.Json

  @@index([maker], map: "IDX_position_maker")
  @@index([taker], map: "IDX_position_taker")
  @@index([chainId, marketAddress], map: "IDX_position_chain_market")
  @@map("position")
}

enum PositionStatus {
  active
  settled
  consolidated
}


model LimitOrder {
  id                Int       @id @default(autoincrement())
  createdAt         DateTime  @default(now()) @db.Timestamp(6)

  // On-chain identifiers
  chainId           Int
  marketAddress     String    @db.VarChar
  orderId           String    @db.VarChar
  maker             String    @db.VarChar
  resolver          String    @db.VarChar
  
  // Order details
  makerCollateral   String    @db.VarChar
  takerCollateral   String    @db.VarChar
  refCode           String?   @db.VarChar
  
  // Status and lifecycle
  status            LimitOrderStatus @default(pending)
  
  // Timestamps
  placedAt          Int
  filledAt          Int?
  cancelledAt       Int?
  
  // Set when order is filled
  taker             String?   @db.VarChar
  
  // Transaction hashes for traceability
  placedTxHash      String    @db.VarChar
  filledTxHash      String?   @db.VarChar
  cancelledTxHash   String?   @db.VarChar
  
  predictions Json      @db.Json
  
  @@unique([chainId, marketAddress, orderId], map: "UQ_limit_order_chain_market_id")
  @@index([maker], map: "IDX_limit_order_maker")
  @@index([chainId, status], map: "IDX_limit_order_chain_status")
  @@index([status], map: "IDX_limit_order_status")
  @@map("limit_order")
}

enum LimitOrderStatus {
  pending
  filled
  cancelled
}

/// Application-level user record, keyed by wallet address,
/// used for referrals and other per-wallet metadata.
model User {
  id           Int      @id @default(autoincrement())
  createdAt    DateTime @default(now()) @db.Timestamp(6)
  updatedAt    DateTime @updatedAt @db.Timestamp(6)

  /// Canonical Ethereum wallet address for this user.
  address      String   @unique(map: "UQ_user_address") @db.VarChar

  /// keccak256(utf8(trimmed_lowercase_code)) stored as 0x-prefixed hex.
  refCodeHash  String?  @unique(map: "UQ_user_ref_code_hash") @db.VarChar

  /// Maximum number of referrals this user's code allows. Default is 0,
  /// so codes are not usable until explicitly configured.
  maxReferrals Int      @default(0)

  referredById Int?
  referredBy   User?   @relation("UserReferrals", fields: [referredById], references: [id])
  referrals    User[]  @relation("UserReferrals")

  @@index([address], map: "IDX_user_address")
  @@map("app_user")
}
