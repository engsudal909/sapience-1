---
title: "Auction Relayer API"
description: "WebSocket API for prediction market auctions between requesters and responders."
---

# Auction Relayer API

The Auction Relayer is a WebSocket service that facilitates real-time matching between **requesters** and **responders** for prediction market positions.

- **Requester**: Creates an auction by specifying a wager and predictions (including one or many picks). Referred to as `taker` in payloads.
- **Responder**: Submits bids offering to take the opposite side. Referred to as `maker` in payloads.

The relayer validates messages, broadcasts auctions to all connected clients, and streams bids to subscribed requesters.

## Endpoint

```
wss://relayer.sapience.xyz/auction
```

This is the standard relayer deployment. You can configure a different relayer in the app at [sapience.xyz/settings](https://sapience.xyz/settings).

## Message Flow

```
Requester                    Relayer                     Responder
    │                           │                            │
    │─── auction.start ────────▶│                            │
    │◀── auction.ack ───────────│                            │
    │                           │─── auction.started ───────▶│
    │                           │                            │
    │                           │◀── bid.submit ─────────────│
    │                           │─── bid.ack ───────────────▶│
    │◀── auction.bids ──────────│                            │
    │                           │                            │
```

1. Requester sends `auction.start` with wager and picks
2. Relayer responds with `auction.ack` (includes `auctionId` and optional `id` if provided) and broadcasts `auction.started` to all clients
3. Responders send `bid.submit` with their wager offer and signature
4. Relayer replies `bid.ack` and streams `auction.bids` to the requester

Requesters are auto-subscribed to their auction's bid stream.

## Quick Start

### Requester: Start an Auction

**Basic example (without signature):**

```ts
import WebSocket from 'ws';

const ws = new WebSocket('wss://relayer.sapience.xyz/auction');

// Initialize an auction
ws.on('open', () => {
  ws.send(JSON.stringify({
    type: 'auction.start',
    payload: {
      taker: '0xRequesterAddress...',
      wager: '1000000000000000000', // 1 USDe in wei
      resolver: '0xResolverContract...',
      predictedOutcomes: ['0xEncodedPick1', '0xEncodedPick2'],
      takerNonce: 1,
      chainId: 42161
    }
  }));
});
```

**With signature (required by some market makers like the vault to respond with actionable bids):**

```ts
import WebSocket from 'ws';
import { 
  createAuctionStartSiweMessage, 
  extractSiweDomainAndUri 
} from '@sapience/sdk';
import { privateKeyToAccount } from 'viem/accounts';

const ws = new WebSocket('wss://relayer.sapience.xyz/auction');
const account = privateKeyToAccount('0xYourPrivateKey...');

ws.on('open', async () => {
  const payload = {
    taker: account.address,
    wager: '1000000000000000000',
    resolver: '0xResolverContract...',
    predictedOutcomes: ['0xEncodedPick1', '0xEncodedPick2'],
    takerNonce: 1,
    chainId: 42161
  };

  // Generate SIWE signature
  const { domain, uri } = extractSiweDomainAndUri('wss://relayer.sapience.xyz/auction');
  const issuedAt = new Date().toISOString();
  const message = createAuctionStartSiweMessage(payload, domain, uri, issuedAt);
  const signature = await account.signMessage({ message });

  ws.send(JSON.stringify({
    type: 'auction.start',
    payload: {
      ...payload,
      takerSignature: signature,
      takerSignedAt: issuedAt
    }
  }));
});

// Listen for bids
ws.on('message', (data) => {
  const msg = JSON.parse(String(data));
  
  if (msg.type === 'auction.ack') {
    console.log('Auction started:', msg.payload.auctionId);
  }
  
  if (msg.type === 'auction.bids') {
    const bids = msg.payload.bids;
    // Filter out quote-only bids (zero address/signature) and expired bids
    const actionableBids = bids.filter(b => {
      return b.maker !== '0x0000000000000000000000000000000000000000' &&
             b.makerSignature !== '0x0000000000000000000000000000000000000000000000000000000000000000' &&
             b.makerDeadline > Date.now() / 1000;
    });
    // Select best bid by highest makerWager
    actionableBids.sort((a, b) => BigInt(b.makerWager) > BigInt(a.makerWager) ? 1 : -1);
    console.log('Best actionable bid:', actionableBids[0]);
  }
});
```

### Responder: Submit a Bid

```ts
const ws = new WebSocket('wss://relayer.sapience.xyz/auction');

// Listen for bids
ws.onmessage = (ev) => {
  const msg = JSON.parse(String(ev.data));
  
  if (msg.type === 'auction.started') {
    const auction = msg.payload;
    const now = Math.floor(Date.now() / 1000);
    
    ws.send(JSON.stringify({
      type: 'bid.submit',
      payload: {
        auctionId: auction.auctionId,
        maker: '0xResponderAddress...',
        makerWager: (BigInt(auction.wager) / 2n).toString(),
        makerDeadline: now + 60,
        makerSignature: '0x...', // EIP-712 typed signature
        makerNonce: 1
      }
    }));
  }
};
```

## Payloads

### `auction.start`

```ts
{
  type: 'auction.start',
  id?: string,                   // Optional request ID for correlation
  payload: {
    taker: string,              // Requester's address (0x...)
    wager: string,              // Wager amount in wei
    resolver: string,           // Resolver contract address
    predictedOutcomes: string[], // Encoded picks (bytes strings)
    takerNonce: number,
    chainId: number,
    takerSignature?: string,    // Optional: EIP-191 signature of the taker (SIWE format)
    takerSignedAt?: string      // Optional: ISO timestamp when signature was created (required if takerSignature is provided)
  }
}
```

If `id` is provided, it will be echoed back in the `auction.ack` response for client-side correlation.

**Signature Requirements:**
- `takerSignature` and `takerSignedAt` are **optional** fields
- **Unsigned requests**: Used for price discovery/quoting only. Market makers may respond with quote-only bids (see below)
- **Signed requests**: Required by some market makers (like the vault) to respond with actionable, signed bids that can be executed on-chain
- When provided, the relayer verifies the signature to ensure the requester authorized the auction request
- Use the SDK's `createAuctionStartSiweMessage` and `extractSiweDomainAndUri` helpers to generate the signature

### `bid.submit`

```ts
{
  type: 'bid.submit',
  payload: {
    auctionId: string,
    maker: string,              // Responder's address
    makerWager: string,         // Responder's wager in wei
    makerDeadline: number,      // Unix timestamp (must be future)
    makerSignature: string,     // EIP-712 signature
    makerNonce: number
  }
}
```

### `auction.bids`

Streamed to auction subscribers:

```ts
{
  type: 'auction.bids',
  payload: {
    auctionId: string,
    bids: Array<{
      auctionId: string,
      maker: string,
      makerWager: string,
      makerDeadline: number,
      makerSignature: string,
      makerNonce: number
    }>
  }
}
```

**Quote-only vs Actionable Bids:**
- **Quote-only bids**: When `maker` is `0x0000000000000000000000000000000000000000` and `makerSignature` is `0x0000...` (all zeros), this indicates a price quote only, not an actionable bid that can be executed on-chain. These are typically returned in response to unsigned auction requests.
- **Actionable bids**: When `maker` is a valid address and `makerSignature` is a real signature, the bid can be accepted and executed on-chain. These are returned in response to signed auction requests (required by some market makers like the vault).

## Validation

**Auction** (`auction.start`):
- `predictedOutcomes` has ≥1 non-empty bytes string
- `taker` is a valid address
- `resolver` is provided
- If `takerSignature` is provided, it must be a valid EIP-191 signature and `takerSignedAt` must be provided
- If signature verification fails, the relayer returns `error: 'invalid_signature'` or `error: 'signature_verification_failed'`

**Bid** (`bid.submit`):
- `auctionId` matches an active auction
- `makerWager` > 0
- `makerDeadline` is in the future
- `makerSignature` is valid hex format

## Additional Messages

### auction.subscribe

Subscribe to an existing auction's bid stream without starting a new auction:

```ts
{
  type: 'auction.subscribe',
  payload: {
    auctionId: string
  }
}
```

This is useful when a secondary client needs to monitor bids for an auction started by another connection.

## Connection Limits

- **Rate limit**: 100 messages per 10 seconds. Exceeding closes connection with code `1008`.
- **Message size**: Max 64KB per message. Exceeding closes connection with code `1009`.

## Error Codes

Returned in `auction.ack.payload.error` or `bid.ack.payload.error`:

**Auction errors:**
- `invalid_signature` – Taker signature verification failed
- `signature_verification_failed` – Error during signature verification process

**Bid errors:**
- `invalid_payload` – Malformed message structure
- `auction_not_found_or_expired` – Unknown or expired auction
- `quote_expired` – `makerDeadline` has passed
- `invalid_maker_wager` – Wager is zero or invalid
- `invalid_maker` – Maker address is invalid
- `invalid_maker_bid_signature_format` – Signature format invalid

## Bid Acceptance

After selecting a bid, the requester constructs a `MintParlayRequestData` struct and calls `mint()` on the PredictionMarket contract. Both parties must have ERC-20 approvals set for the contract to pull their collateral (USDe).

Reference implementation: `packages/api/src/auction/botExample.ts`
